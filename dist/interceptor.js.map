{"version":3,"file":"interceptor.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChBqD;AACC;AACA;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAoB;AAChC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,mEAAoB;AAChC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAe;AACnB;AACA;AACA,QAAQ,8DAAe;AACvB;AACA;;;;;;;;;;;;;;;ACzCO;AACP;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvD8D;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChSkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2CAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCxQA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNkD;AACW;AACX;AAClD;AACA,IAAI,0EAAqB,IAAI;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,+DAAgB;AAChC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,+DAAgB;AAChC,aAAa;AACb,SAAS;AACT;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,CAAC","sources":["webpack://hockeynation/./src/mappings/skill-mappings.ts","webpack://hockeynation/./src/navigation-handler.ts","webpack://hockeynation/./src/observer-handler.ts","webpack://hockeynation/./src/pages/player.ts","webpack://hockeynation/./src/pages/roster.ts","webpack://hockeynation/webpack/bootstrap","webpack://hockeynation/webpack/runtime/define property getters","webpack://hockeynation/webpack/runtime/hasOwnProperty shorthand","webpack://hockeynation/webpack/runtime/make namespace object","webpack://hockeynation/./src/interceptor.ts"],"sourcesContent":["export const SKILL_NAME_TO_ID = {\n    Skating: \"SKA\",\n    Reflexes: \"REF\",\n    Endurance: \"END\",\n    Power: \"PWR\",\n    Positioning: \"POS\",\n    Shooting: \"SHO\",\n    Pads: \"PAD\",\n    Passing: \"PAS\",\n    Glove: \"GLO\",\n    Defending: \"DEF\",\n    Blocker: \"BLO\",\n    Checking: \"CHK\",\n    Stick: \"STK\",\n    Discipline: \"DSC\",\n    Faceoffs: \"FOF\",\n};\n","import { ObserverManager } from \"./observer-handler\";\nimport { manipulatePlayerPage } from \"./pages/player\";\nimport { manipulateRosterPage } from \"./pages/roster\";\nconst PAGE_HANDLERS = {\n    player: {\n        url: \"https://hockey-nation.com/player\",\n        selector: \"table tbody tr\",\n        handler: (table) => {\n            manipulatePlayerPage(table);\n        },\n    },\n    roster: {\n        url: \"https://hockey-nation.com/club/roster\",\n        selector: \"table tbody tr\",\n        handler: (table) => {\n            manipulateRosterPage(table);\n        },\n    },\n};\nfunction findPageHandler(url) {\n    for (const page of Object.values(PAGE_HANDLERS)) {\n        if (url.startsWith(page.url)) {\n            return page;\n        }\n    }\n    return null;\n}\nexport function initNavigationHandler() {\n    handleNavigation();\n    // @ts-ignore\n    window.navigation.addEventListener(\"currententrychange\", handleNavigation);\n}\nfunction handleNavigation() {\n    const url = window.location.href;\n    const pageHandler = findPageHandler(url);\n    // reset previous observer\n    ObserverManager.getInstance().resetCallback();\n    // set new callback if we have a handler for the page\n    if (pageHandler) {\n        ObserverManager.getInstance().setCallback(pageHandler.selector, pageHandler.handler);\n    }\n}\n","export class ObserverManager {\n    static instance;\n    observer = null;\n    currentSelector = null;\n    currentCallback = null;\n    constructor() { } //singleton\n    static getInstance() {\n        if (!ObserverManager.instance) {\n            ObserverManager.instance = new ObserverManager();\n        }\n        return ObserverManager.instance;\n    }\n    setCallback(selector, callback) {\n        this.currentSelector = selector;\n        this.currentCallback = callback;\n        this.ensureObserverActive();\n    }\n    resetCallback() {\n        this.currentSelector = null;\n        this.currentCallback = null;\n    }\n    ensureObserverActive() {\n        if (!this.observer) {\n            this.observer = new MutationObserver((mutations) => {\n                const currentSelector = this.currentSelector;\n                const currentCallback = this.currentCallback;\n                if (!currentSelector || !currentCallback)\n                    return;\n                mutations.forEach((mutation) => {\n                    if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n                        mutation.addedNodes.forEach((node) => {\n                            if (node.nodeType === Node.ELEMENT_NODE) {\n                                const element = node;\n                                const target = element.querySelector(currentSelector);\n                                if (target) {\n                                    currentCallback(element);\n                                    this.disconnect();\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n            this.observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n    disconnect() {\n        if (this.observer) {\n            this.observer.disconnect();\n            this.observer = null;\n        }\n    }\n}\n","import { SKILL_NAME_TO_ID } from \"../mappings/skill-mappings\";\nexport class Player {\n    stats;\n    minStats;\n    maxStats;\n    isScout;\n    constructor(data) {\n        const player = this.parsePlayerData(data);\n        this.stats = player.stats;\n        this.isScout = player.scout;\n        this.minStats = this.calcMinStats(this.stats);\n        this.maxStats = this.calcMaxStats(this.stats);\n    }\n    parsePlayerData(data) {\n        const player = {};\n        player.stats = {};\n        player.scout = data.skills.some((skill) => skill?.hidden ?? false);\n        for (const s of data.skills) {\n            player.stats[s.id] = {\n                rating: parseInt(s?.lvl ?? 0),\n                max: s?.max ?? false,\n                strength: null, // default, change below\n            };\n        }\n        if (data?.talents?.weakest) {\n            // if weakness exists so does strength\n            player.stats[data.talents.weakest].strength = \"weakest\";\n            data.talents.strongest.forEach((str) => (player.stats[str].strength =\n                \"strongest\"));\n        }\n        return player;\n    }\n    calcMinStats(stats) {\n        const minStats = structuredClone(stats);\n        let weakestRating = 10;\n        let highestNonStrongestRating = 0;\n        // update ratings and find the highest non-strongest rating\n        for (const stat of Object.values(minStats)) {\n            stat.rating = stat.max ? stat.rating : stat.rating + 1;\n            if (stat.strength !== \"strongest\") {\n                highestNonStrongestRating = Math.max(highestNonStrongestRating, stat.rating);\n            }\n        }\n        // find the weakest rating\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"weakest\") {\n                weakestRating = stat.rating;\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"strongest\" &&\n                stat.rating < highestNonStrongestRating) {\n                stat.rating = highestNonStrongestRating;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.rating < weakestRating) {\n                stat.rating = weakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return minStats;\n    }\n    calcMaxStats(stats) {\n        const maxStats = structuredClone(stats);\n        let strongestRating = 10;\n        let lowestNonWeakestRating = 10;\n        // find the strongest rating\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\") {\n                strongestRating = Math.min(strongestRating, stat.max ? stat.rating : 10);\n            }\n        }\n        // update ratings and find the lowest non-weakest rating\n        for (const stat of Object.values(maxStats)) {\n            if (!stat.max && stat.rating < strongestRating) {\n                stat.rating = strongestRating;\n            }\n            if (stat.strength !== \"weakest\") {\n                lowestNonWeakestRating = Math.min(lowestNonWeakestRating, stat.rating);\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\" && !stat.max && stat.rating < 10) {\n                stat.rating = 10;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"weakest\" && stat.rating > lowestNonWeakestRating) {\n                stat.rating = lowestNonWeakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return maxStats;\n    }\n    getStats() {\n        return this.stats;\n    }\n    getMinStats() {\n        return this.minStats;\n    }\n    getMaxStats() {\n        return this.maxStats;\n    }\n    calculateOVR(stats) {\n        const statsValues = Object.values(stats);\n        const sum = statsValues.reduce((acc, stat) => acc + stat.rating, 0);\n        const avg = sum / statsValues.length;\n        const excess = statsValues.reduce((acc, stat) => stat.rating > avg ? acc + stat.rating - avg : acc, 0);\n        const correctedSum = sum + excess;\n        const correctedAverage = correctedSum / statsValues.length;\n        return Math.round(correctedAverage * 10);\n    }\n}\nclass PlayerStatsVisualizer {\n    playerStats;\n    parentNode;\n    ovrElement = null;\n    baseOVR = null;\n    statsTable = null;\n    statsRows = null;\n    constructor(playerStats, parentNode) {\n        this.playerStats = playerStats;\n        this.parentNode = parentNode;\n        this.initialize();\n    }\n    initialize() {\n        const puck = this.parentNode.querySelector(\"svg.fa-hockey-puck\");\n        if (!puck) {\n            return;\n        }\n        // this.statsTable = ancestor as HTMLTableElement | null;\n        this.statsTable = puck.closest(`tbody`);\n        if (!this.statsTable) {\n            return;\n        }\n        // get stats rows\n        this.statsRows =\n            this.statsTable.querySelectorAll(\"tr\");\n        if (!this.statsRows.length) {\n            return;\n        }\n        // get OVR element\n        this.ovrElement =\n            this.parentNode.querySelector(\".polygon text\");\n        this.baseOVR = this.ovrElement ? this.ovrElement.textContent : null;\n        // add dropdown to skills header\n        this.addDropdown();\n        // initialize display\n        this.updateHockeyPucks(\"Default\");\n    }\n    // Consider not adding / disabling twhen all of a player's stats are maxed\n    addDropdown() {\n        const div = Array.from(document.querySelectorAll(\".card-header\")).filter((d) => d?.textContent?.trim() === \"Skills\")?.[0];\n        if (div === undefined)\n            return;\n        if (div.querySelector(\".stats-dropdown\"))\n            return;\n        const dropdown = document.createElement(\"select\");\n        dropdown.classList.add(\"stats-dropdown\");\n        dropdown.style.marginLeft = \"auto\";\n        dropdown.style.fontSize = \"12px\";\n        dropdown.style.padding = \"2px\";\n        dropdown.style.border = \"none\";\n        dropdown.style.backgroundColor = \"#fff\";\n        dropdown.style.color = \"#000\";\n        dropdown.style.width = \"85px\";\n        dropdown.style.height = \"18px\";\n        dropdown.style.lineHeight = \"18px\";\n        dropdown.style.paddingTop = \"0px\";\n        dropdown.style.paddingBottom = \"0px\";\n        dropdown.style.paddingRight = \"21px\";\n        dropdown.style.borderRadius = \"2px\";\n        dropdown.addEventListener(\"change\", (event) => {\n            const selectElement = event.target;\n            const selectedOption = selectElement.value;\n            this.updateHockeyPucks(selectedOption);\n        });\n        const options = [\"Default\", \"Min\", \"Max\"];\n        options.forEach((option) => {\n            const optionElement = document.createElement(\"option\");\n            optionElement.value = option;\n            optionElement.textContent = option;\n            optionElement.style.textAlign = \"center\";\n            dropdown.appendChild(optionElement);\n        });\n        div.appendChild(dropdown);\n    }\n    updateHockeyPucks(option) {\n        if (!this.statsRows)\n            return;\n        const statsToUse = option === \"Min\"\n            ? this.playerStats.minStats\n            : option === \"Max\"\n                ? this.playerStats.maxStats\n                : this.playerStats.stats;\n        this.statsRows.forEach((row) => {\n            const statName = SKILL_NAME_TO_ID[row.cells[0]?.textContent?.trim() || \"\"];\n            const pucksCell = row.cells[1];\n            const pucks = pucksCell.querySelectorAll(\"svg.fa-hockey-puck\");\n            const ratingCell = row.cells[2];\n            const ratingSpan = ratingCell?.querySelector(\"span\");\n            const baseStat = this.playerStats.stats[statName];\n            const displayStat = statsToUse[statName];\n            if (baseStat && displayStat) {\n                pucks.forEach((puck, index) => {\n                    puck.classList.remove(\"text-blue-400\");\n                    if (index < displayStat.rating) {\n                        puck.classList.remove(\"text-gray-300\");\n                        if (index >= baseStat.rating) {\n                            puck.classList.add(\"text-blue-400\");\n                        }\n                    }\n                    else {\n                        puck.classList.add(\"text-gray-300\");\n                    }\n                    if (index === displayStat.rating - 1 && baseStat.max) {\n                        puck.classList.add(\"max-level\");\n                    }\n                    else {\n                        puck.classList.remove(\"max-level\");\n                    }\n                });\n                // update the rating value in the span element\n                if (ratingSpan) {\n                    ratingSpan.textContent = `(${displayStat.rating})`;\n                }\n            }\n        });\n        // update OVR\n        let ovr = this.playerStats.calculateOVR(statsToUse);\n        if (option !== \"Default\" || !this.playerStats.isScout) {\n            this.updateOVR(ovr);\n        }\n        else if (this.baseOVR !== null) {\n            this.updateOVR(parseInt(this.baseOVR));\n        }\n    }\n    updateOVR(ovr) {\n        if (!this.ovrElement)\n            return;\n        this.ovrElement.textContent = ovr.toString();\n        const polygonElement = this.ovrElement.parentElement?.querySelector(\"polygon\");\n        if (polygonElement) {\n            let fillColor = \"\";\n            if (ovr <= 39) {\n                fillColor = \"#f56565\";\n            }\n            else if (ovr >= 40 && ovr <= 54) {\n                fillColor = \"#ed8936\";\n            }\n            else if (ovr >= 55 && ovr <= 69) {\n                fillColor = \"#1995AD\";\n            }\n            else if (ovr >= 70 && ovr <= 79) {\n                fillColor = \"#10b981\";\n            }\n            else if (ovr >= 80) {\n                fillColor = \"#383839\";\n            }\n            polygonElement.setAttribute(\"fill\", fillColor);\n        }\n    }\n}\nexport function handlePlayerData(data) {\n    window.playerData = new Player(data);\n    const event = new CustomEvent(\"playerDataReady\");\n    window.dispatchEvent(event);\n}\nexport function manipulatePlayerPage(table) {\n    if (window.playerData) {\n        new PlayerStatsVisualizer(window.playerData, table);\n    }\n    else {\n        const handler = () => {\n            new PlayerStatsVisualizer(window.playerData, table);\n            window.removeEventListener(\"playerDataReady\", handler);\n        };\n        window.addEventListener(\"playerDataReady\", handler);\n    }\n}\n","import { Player } from \"./player\";\nclass Roster {\n    players;\n    constructor(data) {\n        this.players = this.parseRosterData(data);\n    }\n    parseRosterData(data) {\n        const roster = {};\n        for (const p of data.players) {\n            roster[p.id] = new Player(p);\n        }\n        return roster;\n    }\n    getPlayer(playerId) {\n        return this.players[playerId];\n    }\n    getAllPlayers() {\n        return this.players;\n    }\n}\nclass RosterStatsVisualizer {\n    roster;\n    parent;\n    header = null;\n    footer = null;\n    dataRows = null;\n    generalButton = null;\n    skillsButton = null;\n    tbody = null;\n    onGeneralPage = true;\n    minHeaderCell = null;\n    maxHeaderCell = null;\n    // private sortColumn: \"min-ovr\" | \"max-ovr\" | null = null;\n    // private sortAscending: boolean = true;\n    constructor(roster, parentNode) {\n        this.roster = roster;\n        this.parent = parentNode;\n        this.initialize();\n    }\n    initialize() {\n        this.generalButton = this.parent.querySelector(`.btn-toggle.active`);\n        if (!this.generalButton)\n            return;\n        this.skillsButton = this.parent.querySelector(`.btn-toggle:not(.active)`);\n        if (!this.skillsButton)\n            return;\n        this.generalButton.addEventListener(\"click\", async (event) => {\n            if (this.onGeneralPage)\n                return;\n            this.onGeneralPage = true;\n            // re-initialize the table references since dom has changed\n            this.initializeTableReferences();\n            if (this.dataRows && Object.keys(this.dataRows).length > 0) {\n                this.addNewColumns();\n            }\n            // if (this.sortColumn) this.sortRows()\n        });\n        this.skillsButton.addEventListener(\"click\", (event) => {\n            if (!this.onGeneralPage)\n                return;\n            this.onGeneralPage = false;\n            this.initializeTableReferences();\n            // if (this.sortColumn) this.sortRows();\n        });\n        // initialize table references and add columns on first load\n        this.initializeTableReferences();\n        if (this.dataRows && Object.keys(this.dataRows).length > 0) {\n            this.addNewColumns();\n        }\n    }\n    initializeTableReferences() {\n        // reset references to get the latest dom nodes\n        this.header = this.parent.querySelector(`table thead tr`);\n        this.footer = this.parent.querySelector(`table tfoot tr`);\n        this.tbody = this.parent.querySelector(\"table tbody\");\n        // const headerElements = this.header?.querySelectorAll(`th`);\n        // headerElements?.forEach((node) =>\n        //   node.addEventListener(\"click\", () => {\n        //     this.sortColumn = null;\n        //     this.sortAscending = false;\n        //   }),\n        // );\n        const rows = this.parent.querySelectorAll(`tbody tr`);\n        const dr = {};\n        rows.forEach((row) => {\n            const tableRow = row;\n            const playerLink = tableRow.querySelector(\"a.player-link\");\n            if (playerLink?.getAttribute(\"href\")) {\n                const playerId = playerLink.getAttribute(\"href\").split(\"/\").pop() || \"\";\n                dr[playerId] = tableRow;\n            }\n        });\n        this.dataRows = dr;\n    }\n    getRosterAvgOvr(ovrType) {\n        const statFunction = {\n            Default: (player) => player.getStats(),\n            Min: (player) => player.getMinStats(),\n            Max: (player) => player.getMaxStats(),\n        };\n        const players = this.roster.getAllPlayers();\n        return Math.round(Object.values(players)\n            .map((player) => player.calculateOVR(statFunction[ovrType](player)))\n            .reduce((sum, value, _, array) => sum + value / array.length, 0));\n    }\n    getRowPlayerName(row) {\n        const fullName = row\n            .querySelector(`a.player-link span`)\n            ?.textContent?.trim();\n        const [firstname = \"\", lastname = \"\"] = fullName?.split(\" \") ?? [];\n        return [firstname, lastname];\n    }\n    createRatingSpan(ovr) {\n        const ratingSpan = document.createElement(\"span\");\n        ratingSpan.classList.add(\"badge\");\n        ratingSpan.style.color = \"#f8f8f9\";\n        ratingSpan.style.userSelect = \"none\";\n        let bgColor = \"\";\n        if (ovr <= 39) {\n            bgColor = \"#f56565\";\n        }\n        else if (ovr >= 40 && ovr <= 54) {\n            bgColor = \"#ed8936\";\n        }\n        else if (ovr >= 55 && ovr <= 69) {\n            bgColor = \"#1995AD\";\n        }\n        else if (ovr >= 70 && ovr <= 79) {\n            bgColor = \"#10b981\";\n        }\n        else if (ovr >= 80) {\n            bgColor = \"#383839\";\n        }\n        ratingSpan.style.backgroundColor = bgColor;\n        ratingSpan.innerText = ovr.toString();\n        return ratingSpan;\n    }\n    // private addSorting(): void { if (!this.minHeaderCell || !this.maxHeaderCell) return;\n    //   // min ovr sorting\n    //   this.minHeaderCell.addEventListener(\"click\", () => {\n    //     if (this.sortColumn === \"min-ovr\") {\n    //       // if already sorting by this column, toggle direction\n    //       this.sortAscending = !this.sortAscending;\n    //     } else {\n    //       this.sortColumn = \"min-ovr\";\n    //       this.sortAscending = false; // default descending\n    //     }\n    //     this.sortRows();\n    //   });\n    //   // max ovr sorting\n    //   this.maxHeaderCell.addEventListener(\"click\", () => {\n    //     if (this.sortColumn === \"max-ovr\") {\n    //       this.sortAscending = !this.sortAscending;\n    //     } else {\n    //       this.sortColumn = \"max-ovr\";\n    //       this.sortAscending = false;\n    //     }\n    //     this.sortRows();\n    //   });\n    // }\n    // private sortRows(): void {\n    //   if (!this.dataRows || !this.sortColumn || !this.tbody) return;\n    //   console.log(\"1\");\n    //   const tbody = this.tbody;\n    //   const rows = Object.entries(this.dataRows).map(([playerId, row]) => {\n    //     console.log(\"rrrr\");\n    //     const player = this.roster.getPlayer(playerId);\n    //     const ovrValue = player\n    //       ? this.sortColumn === \"min-ovr\"\n    //         ? player.calculateOVR(player.getMinStats())\n    //         : player.calculateOVR(player.getMaxStats())\n    //       : 0;\n    //     const [firstName, lastName] = this.getRowPlayerName(row);\n    //     return {\n    //       row,\n    //       ovrValue,\n    //       firstName,\n    //       lastName,\n    //       playerId,\n    //     };\n    //   });\n    //   const collator = new Intl.Collator(undefined, {\n    //     usage: \"sort\",\n    //     sensitivity: \"base\",\n    //   });\n    //   rows.sort((a, b) => {\n    //     if (a.ovrValue !== b.ovrValue) {\n    //       return this.sortAscending\n    //         ? a.ovrValue - b.ovrValue\n    //         : b.ovrValue - a.ovrValue;\n    //     }\n    //     const lastNameCompare = collator.compare(a.lastName, b.lastName);\n    //     if (lastNameCompare !== 0) {\n    //       return this.sortAscending ? lastNameCompare : -lastNameCompare;\n    //     }\n    //     return this.sortAscending\n    //       ? collator.compare(a.firstName, b.firstName)\n    //       : collator.compare(b.firstName, a.firstName);\n    //   });\n    //   rows.forEach((item) => {\n    //     console.log(\"appending row?!\", item);\n    //     tbody.appendChild(item.row);\n    //   });\n    // }\n    addNewColumns() {\n        if (!this.dataRows || !this.header || !this.footer)\n            return;\n        // safety incase columns are already added\n        const headerText = this.header.textContent || \"\";\n        if (headerText.includes(\" Min \") && headerText.includes(\" Max \")) {\n            return;\n        }\n        Object.entries(this.dataRows).forEach(([playerId, row]) => {\n            const player = this.roster.getPlayer(playerId);\n            if (!player)\n                return;\n            const minDataCell = document.createElement(\"td\");\n            minDataCell.className = \"md:px-4 px-2 py-2 text-center\";\n            minDataCell.dataset.column = \"min-ovr\";\n            minDataCell.appendChild(this.createRatingSpan(player.calculateOVR(player.getMinStats())));\n            const maxDataCell = document.createElement(\"td\");\n            maxDataCell.className = \"md:px-4 px-2 py-2 text-center\";\n            maxDataCell.dataset.column = \"max-ovr\";\n            maxDataCell.appendChild(this.createRatingSpan(player.calculateOVR(player.getMaxStats())));\n            row.insertBefore(minDataCell, null);\n            row.insertBefore(maxDataCell, null);\n        });\n        this.minHeaderCell = document.createElement(\"th\");\n        this.minHeaderCell.className = \"md:px-4 px-2 py-2 text-left sort-column\";\n        this.minHeaderCell.innerText = \" Min \";\n        this.minHeaderCell.style.textAlign = \"center\";\n        this.maxHeaderCell = document.createElement(\"th\");\n        this.maxHeaderCell.className = \"md:px-4 px-2 py-2 text-left sort-column\";\n        this.maxHeaderCell.innerText = \" Max \";\n        this.maxHeaderCell.style.textAlign = \"center\";\n        this.header.insertBefore(this.minHeaderCell, null);\n        this.header.insertBefore(this.maxHeaderCell, null);\n        const minFooterCell = document.createElement(\"td\");\n        minFooterCell.className = \"md:px-4 px-2 py-2\";\n        minFooterCell.appendChild(this.createRatingSpan(this.getRosterAvgOvr(\"Min\")));\n        const maxFooterCell = document.createElement(\"td\");\n        maxFooterCell.className = \"md:px-4 px-2 py-2\";\n        maxFooterCell.appendChild(this.createRatingSpan(this.getRosterAvgOvr(\"Max\")));\n        this.footer.insertBefore(minFooterCell, null);\n        this.footer.insertBefore(maxFooterCell, null);\n        // this.addSorting();\n    }\n}\nexport function handleRosterData(data) {\n    window.rosterData = new Roster(data);\n    const event = new CustomEvent(\"rosterDataReady\");\n    window.dispatchEvent(event);\n}\nexport function manipulateRosterPage(table) {\n    if (window.rosterData) {\n        new RosterStatsVisualizer(window.rosterData, table);\n    }\n    else {\n        const handler = () => {\n            new RosterStatsVisualizer(window.rosterData, table);\n            window.removeEventListener(\"rosterDataReady\", handler);\n        };\n        window.addEventListener(\"rosterDataReady\", handler);\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { handlePlayerData } from \"./pages/player\";\nimport { initNavigationHandler } from \"./navigation-handler\";\nimport { handleRosterData } from \"./pages/roster\";\n(function () {\n    initNavigationHandler(); // Initialize Observer from script context\n    const URL_HANDLERS = {\n        player: {\n            pattern: /\\/api\\/player\\/[^\\/]+$/,\n            handler: (data) => {\n                handlePlayerData(data);\n            },\n        },\n        roster: {\n            pattern: /\\/api\\/team\\/[^\\/]+\\/roster/,\n            handler: (data) => {\n                handleRosterData(data);\n            },\n        },\n    };\n    function findHandler(url) {\n        for (const { pattern, handler } of Object.values(URL_HANDLERS)) {\n            if (pattern.test(url))\n                return handler;\n        }\n        return null;\n    }\n    class Interceptor extends XMLHttpRequest {\n        interceptedUrl = null;\n        // @ts-ignore\n        open(method, url, ...rest) {\n            this.interceptedUrl = url;\n            // @ts-ignore\n            super.open(method, url, ...rest);\n        }\n        send(...args) {\n            const handler = findHandler(this.interceptedUrl ?? \"\");\n            if (handler) {\n                const originalOnReadyState = this.onreadystatechange;\n                this.onreadystatechange = function () {\n                    if (this.readyState === 4 && this.status === 200) {\n                        try {\n                            const { data } = JSON.parse(this.responseText);\n                            handler(data);\n                        }\n                        catch (e) {\n                            console.error(\"Error parsing response:\", e);\n                        }\n                    }\n                    if (originalOnReadyState) {\n                        // @ts-ignore\n                        originalOnReadyState.apply(this, arguments);\n                    }\n                };\n            }\n            super.send(...args);\n        }\n    }\n    window.XMLHttpRequest = Interceptor;\n    // intercept fetch as well, although I don't think this is used\n    const originalFetch = window.fetch;\n    window.fetch = async function (resource, init) {\n        // handle strings & request obj\n        const url = typeof resource === \"string\"\n            ? resource\n            : resource instanceof Request\n                ? resource.url\n                : resource.toString();\n        const response = await originalFetch.call(this, resource, init);\n        const handler = url && findHandler(url);\n        if (handler) {\n            try {\n                const clonedResponse = response.clone();\n                const data = await clonedResponse.json();\n                handler(data);\n            }\n            catch (e) {\n                console.error(\"Error processing fetch response:\", e);\n            }\n        }\n        return response;\n    };\n    /////\n    // const origAdd = EventTarget.prototype.addEventListener;\n    // EventTarget.prototype.addEventListener = function (type, listener, options) {\n    //   if (type === \"click\") {\n    //     // @ts-ignore\n    //     const wrapped = (e) => {\n    //       console.log(\"before\");\n    //       // @ts-ignore\n    //       listener.call(this, e);\n    //       console.log(\"after\");\n    //     };\n    //     origAdd.call(this, type, wrapped, options);\n    //   } else {\n    //     origAdd.call(this, type, listener, options);\n    //   }\n    // };\n})();\n"],"names":[],"sourceRoot":""}