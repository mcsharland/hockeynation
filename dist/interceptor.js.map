{"version":3,"file":"interceptor.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChBqD;AACC;AACA;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAoB;AAChC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,mEAAoB;AAChC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAe;AACnB;AACA;AACA,QAAQ,8DAAe;AACvB;AACA;;;;;;;;;;;;;;;ACzCO;AACP;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvD8D;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrTkC;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2CAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D,yCAAyC,OAAO;AAChD,yCAAyC,OAAO;AAChD;AACA;AACA;AACO;AACP;AACA;;;;;;;UCnDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNkD;AACW;AACX;AACJ;AAC9C;AACA,IAAI,0EAAqB,IAAI;AAC7B,0BAA0B,uCAAI,IAAI;AAClC;AACA;AACA;AACA;AACA,gBAAgB,+DAAgB;AAChC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,+DAAgB;AAChC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,qDAAc;AAC9B,aAAa;AACb,SAAS;AACT;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://hockeynation/./src/mappings/skill-mappings.ts","webpack://hockeynation/./src/navigation-handler.ts","webpack://hockeynation/./src/observer-handler.ts","webpack://hockeynation/./src/pages/player.ts","webpack://hockeynation/./src/pages/roster.ts","webpack://hockeynation/./src/user.ts","webpack://hockeynation/webpack/bootstrap","webpack://hockeynation/webpack/runtime/define property getters","webpack://hockeynation/webpack/runtime/hasOwnProperty shorthand","webpack://hockeynation/webpack/runtime/make namespace object","webpack://hockeynation/./src/interceptor.ts"],"sourcesContent":["export const SKILL_NAME_TO_ID = {\n    Skating: \"SKA\",\n    Reflexes: \"REF\",\n    Endurance: \"END\",\n    Power: \"PWR\",\n    Positioning: \"POS\",\n    Shooting: \"SHO\",\n    Pads: \"PAD\",\n    Passing: \"PAS\",\n    Glove: \"GLO\",\n    Defending: \"DEF\",\n    Blocker: \"BLO\",\n    Checking: \"CHK\",\n    Stick: \"STK\",\n    Discipline: \"DSC\",\n    Faceoffs: \"FOF\",\n};\n","import { ObserverManager } from \"./observer-handler\";\nimport { manipulatePlayerPage } from \"./pages/player\";\nimport { manipulateRosterPage } from \"./pages/roster\";\nconst PAGE_HANDLERS = {\n    player: {\n        url: \"https://hockey-nation.com/player\",\n        selector: \"table tbody tr\",\n        handler: (table) => {\n            manipulatePlayerPage(table);\n        },\n    },\n    roster: {\n        url: \"https://hockey-nation.com/club/roster\",\n        selector: \"table tbody tr\",\n        handler: (table) => {\n            manipulateRosterPage(table);\n        },\n    },\n};\nfunction findPageHandler(url) {\n    for (const page of Object.values(PAGE_HANDLERS)) {\n        if (url.startsWith(page.url)) {\n            return page;\n        }\n    }\n    return null;\n}\nexport function initNavigationHandler() {\n    handleNavigation();\n    // @ts-ignore\n    window.navigation.addEventListener(\"currententrychange\", handleNavigation);\n}\nfunction handleNavigation() {\n    const url = window.location.href;\n    const pageHandler = findPageHandler(url);\n    // reset previous observer\n    ObserverManager.getInstance().resetCallback();\n    // set new callback if we have a handler for the page\n    if (pageHandler) {\n        ObserverManager.getInstance().setCallback(pageHandler.selector, pageHandler.handler);\n    }\n}\n","export class ObserverManager {\n    static instance;\n    observer = null;\n    currentSelector = null;\n    currentCallback = null;\n    constructor() { } //singleton\n    static getInstance() {\n        if (!ObserverManager.instance) {\n            ObserverManager.instance = new ObserverManager();\n        }\n        return ObserverManager.instance;\n    }\n    setCallback(selector, callback) {\n        this.currentSelector = selector;\n        this.currentCallback = callback;\n        this.ensureObserverActive();\n    }\n    resetCallback() {\n        this.currentSelector = null;\n        this.currentCallback = null;\n    }\n    ensureObserverActive() {\n        if (!this.observer) {\n            this.observer = new MutationObserver((mutations) => {\n                const currentSelector = this.currentSelector;\n                const currentCallback = this.currentCallback;\n                if (!currentSelector || !currentCallback)\n                    return;\n                mutations.forEach((mutation) => {\n                    if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n                        mutation.addedNodes.forEach((node) => {\n                            if (node.nodeType === Node.ELEMENT_NODE) {\n                                const element = node;\n                                const target = element.querySelector(currentSelector);\n                                if (target) {\n                                    currentCallback(element);\n                                    this.disconnect();\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n            this.observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n    disconnect() {\n        if (this.observer) {\n            this.observer.disconnect();\n            this.observer = null;\n        }\n    }\n}\n","import { SKILL_NAME_TO_ID } from \"../mappings/skill-mappings\";\nexport class Player {\n    stats;\n    minStats;\n    maxStats;\n    isScout;\n    ovr;\n    minOvr;\n    maxOvr;\n    constructor(data) {\n        const player = this.parsePlayerData(data);\n        this.stats = player.stats;\n        this.isScout = player.scout;\n        this.minStats = this.calcMinStats(this.stats);\n        this.maxStats = this.calcMaxStats(this.stats);\n        this.ovr = data?.rating ?? 0;\n        this.minOvr = this.calculateOVR(this.minStats);\n        this.maxOvr = this.calculateOVR(this.maxStats);\n    }\n    parsePlayerData(data) {\n        const player = {};\n        player.stats = {};\n        player.scout = data.skills.every((skill) => skill?.hidden ?? false);\n        for (const s of data.skills) {\n            player.stats[s.id] = {\n                rating: parseInt(s?.lvl ?? 0),\n                max: s?.max ?? false,\n                strength: null, // default, change below\n            };\n        }\n        if (data?.talents?.weakest) {\n            // if weakness exists so does strength\n            player.stats[data.talents.weakest].strength = \"weakest\";\n            data.talents.strongest.forEach((str) => (player.stats[str].strength =\n                \"strongest\"));\n        }\n        return player;\n    }\n    calcMinStats(stats) {\n        const minStats = structuredClone(stats);\n        let weakestRating = 10;\n        let highestNonStrongestRating = 0;\n        // update ratings and find the highest non-strongest rating\n        for (const stat of Object.values(minStats)) {\n            stat.rating = stat.max ? stat.rating : stat.rating + 1;\n            if (stat.strength !== \"strongest\") {\n                highestNonStrongestRating = Math.max(highestNonStrongestRating, stat.rating);\n            }\n        }\n        // find the weakest rating\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"weakest\") {\n                weakestRating = stat.rating;\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"strongest\" &&\n                stat.rating < highestNonStrongestRating) {\n                stat.rating = highestNonStrongestRating;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.rating < weakestRating) {\n                stat.rating = weakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return minStats;\n    }\n    calcMaxStats(stats) {\n        const maxStats = structuredClone(stats);\n        let strongestRating = 10;\n        let lowestNonWeakestRating = 10;\n        // find the strongest rating\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\") {\n                strongestRating = Math.min(strongestRating, stat.max ? stat.rating : 10);\n            }\n        }\n        // update ratings and find the lowest non-weakest rating\n        for (const stat of Object.values(maxStats)) {\n            if (!stat.max && stat.rating < strongestRating) {\n                stat.rating = strongestRating;\n            }\n            if (stat.strength !== \"weakest\") {\n                lowestNonWeakestRating = Math.min(lowestNonWeakestRating, stat.rating);\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\" && !stat.max && stat.rating < 10) {\n                stat.rating = 10;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"weakest\" && stat.rating > lowestNonWeakestRating) {\n                stat.rating = lowestNonWeakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return maxStats;\n    }\n    getStats() {\n        return this.stats;\n    }\n    getMinStats() {\n        return this.minStats;\n    }\n    getMaxStats() {\n        return this.maxStats;\n    }\n    getIsScout() {\n        return this.isScout;\n    }\n    // TODO:\n    // Needs to be improved for scout players. Full hidden players need to not have a calculated OVR / be treated special so that roster page calculations work fine\n    // Look at playerdata.canScout & scoutedTimes\n    getOvr() {\n        return this.ovr;\n    }\n    getMaxOvr() {\n        return Math.max(this.maxOvr, this.ovr); // handles cases where ovr is known through scouting, but stats are unknown\n    }\n    getMinOvr() {\n        return Math.max(this.minOvr, this.ovr);\n    }\n    // probably make this private\n    calculateOVR(stats) {\n        if (this.isScout)\n            return 0;\n        const statsValues = Object.values(stats);\n        const sum = statsValues.reduce((acc, stat) => acc + stat.rating, 0);\n        const avg = sum / statsValues.length;\n        const excess = statsValues.reduce((acc, stat) => stat.rating > avg ? acc + stat.rating - avg : acc, 0);\n        const correctedSum = sum + excess;\n        const correctedAverage = correctedSum / statsValues.length;\n        return Math.round(correctedAverage * 10);\n    }\n}\n// TODO: create user class to seed colors for OVR\nclass PlayerStatsVisualizer {\n    playerStats;\n    parentNode;\n    ovrElement = null;\n    statsTable = null;\n    statsRows = null;\n    constructor(playerStats, parentNode) {\n        this.playerStats = playerStats;\n        this.parentNode = parentNode;\n        this.initialize();\n    }\n    initialize() {\n        const puck = this.parentNode.querySelector(\"svg.fa-hockey-puck\");\n        if (!puck) {\n            return;\n        }\n        this.statsTable = puck.closest(`tbody`);\n        if (!this.statsTable) {\n            return;\n        }\n        // get stats rows\n        this.statsRows =\n            this.statsTable.querySelectorAll(\"tr\");\n        if (!this.statsRows.length) {\n            return;\n        }\n        // get OVR element\n        this.ovrElement =\n            this.parentNode.querySelector(\".polygon text\");\n        // add dropdown to skills header\n        this.addDropdown();\n        // initialize display\n        this.updateHockeyPucks(\"Default\");\n    }\n    // Consider not adding / disabling when all of a player's stats are maxed\n    addDropdown() {\n        const div = Array.from(document.querySelectorAll(\".card-header\")).filter((d) => d?.textContent?.trim() === \"Skills\")?.[0];\n        if (div === undefined)\n            return;\n        if (div.querySelector(\".stats-dropdown\"))\n            return;\n        const dropdown = document.createElement(\"select\");\n        dropdown.classList.add(\"stats-dropdown\");\n        dropdown.style.marginLeft = \"auto\";\n        dropdown.style.fontSize = \"12px\";\n        dropdown.style.padding = \"2px\";\n        dropdown.style.border = \"none\";\n        dropdown.style.backgroundColor = \"#fff\";\n        dropdown.style.color = \"#000\";\n        dropdown.style.width = \"85px\";\n        dropdown.style.height = \"18px\";\n        dropdown.style.lineHeight = \"18px\";\n        dropdown.style.paddingTop = \"0px\";\n        dropdown.style.paddingBottom = \"0px\";\n        dropdown.style.paddingRight = \"21px\";\n        dropdown.style.borderRadius = \"2px\";\n        dropdown.addEventListener(\"change\", (event) => {\n            const selectElement = event.target;\n            const selectedOption = selectElement.value;\n            this.updateHockeyPucks(selectedOption);\n        });\n        const options = [\"Default\", \"Min\", \"Max\"];\n        options.forEach((option) => {\n            const optionElement = document.createElement(\"option\");\n            optionElement.value = option;\n            optionElement.textContent = option;\n            optionElement.style.textAlign = \"center\";\n            dropdown.appendChild(optionElement);\n        });\n        div.appendChild(dropdown);\n    }\n    // TODO: Check user class to determine if number should be rendered\n    // might be able to simplify this simply by checking if element to set the number exist\n    updateHockeyPucks(option) {\n        if (!this.statsRows)\n            return;\n        const statsToUse = option === \"Min\"\n            ? this.playerStats.getMinStats()\n            : option === \"Max\"\n                ? this.playerStats.getMaxStats()\n                : this.playerStats.getStats();\n        this.statsRows.forEach((row) => {\n            const statName = SKILL_NAME_TO_ID[row.cells[0]?.textContent?.trim() || \"\"];\n            const pucksCell = row.cells[1];\n            const pucks = pucksCell.querySelectorAll(\"svg.fa-hockey-puck\");\n            const ratingCell = row.cells[2];\n            const ratingSpan = ratingCell?.querySelector(\"span\");\n            const baseStat = this.playerStats.getStats()[statName];\n            const displayStat = statsToUse[statName];\n            if (baseStat && displayStat) {\n                pucks.forEach((puck, index) => {\n                    puck.classList.remove(\"text-blue-400\");\n                    if (index < displayStat.rating) {\n                        puck.classList.remove(\"text-gray-300\");\n                        if (index >= baseStat.rating) {\n                            puck.classList.add(\"text-blue-400\");\n                        }\n                    }\n                    else {\n                        puck.classList.add(\"text-gray-300\");\n                    }\n                    if (index === displayStat.rating - 1 && baseStat.max) {\n                        puck.classList.add(\"max-level\");\n                    }\n                    else {\n                        puck.classList.remove(\"max-level\");\n                    }\n                });\n                // update the rating value in the span element\n                if (ratingSpan) {\n                    ratingSpan.textContent = `(${displayStat.rating})`;\n                }\n            }\n        });\n        // update OVR\n        const ovr = option === \"Min\"\n            ? this.playerStats.getMinOvr()\n            : option === \"Max\"\n                ? this.playerStats.getMaxOvr()\n                : this.playerStats.getOvr();\n        // TODO:\n        // This is the only time that isScout is used, and it is a fail safe for OVR calculations where stats are missing.\n        // The other thing that I can think of, is that MIN OVR should be calculate as the min of the resulting value and the default\n        // // the logic in the original stil calculated stats for scouts as long as the OVR element wasn't null\n        // i think that its more crucial to check if all values are hidden, since there no other reliable way to determine if someone\n        // is fully hidden from the user just looking at the player data, at least within the roster. More reliable to just check if all stats are hidden\n        if (option !== \"Default\" || !this.playerStats.getIsScout()) {\n            this.updateOVR(ovr);\n        }\n        else if (this.playerStats.getOvr() !== 0) {\n            this.updateOVR(this.playerStats.getOvr());\n        }\n    }\n    updateOVR(ovr) {\n        if (!this.ovrElement)\n            return;\n        this.ovrElement.textContent = ovr.toString();\n        const polygonElement = this.ovrElement.parentElement?.querySelector(\"polygon\");\n        if (polygonElement) {\n            if (window.userData) {\n                polygonElement.setAttribute(\"fill\", window.userData.getColorPair(ovr)[0]);\n                this.ovrElement.setAttribute(\"fill\", window.userData.getColorPair(ovr)[1]);\n            }\n        }\n    }\n}\nexport function handlePlayerData(data) {\n    window.playerData = new Player(data);\n    const event = new CustomEvent(\"playerDataReady\");\n    window.dispatchEvent(event);\n}\nexport function manipulatePlayerPage(table) {\n    if (window.playerData) {\n        new PlayerStatsVisualizer(window.playerData, table);\n    }\n    else {\n        const handler = () => {\n            new PlayerStatsVisualizer(window.playerData, table);\n            window.removeEventListener(\"playerDataReady\", handler);\n        };\n        window.addEventListener(\"playerDataReady\", handler);\n    }\n}\n","import { Player } from \"./player\";\nexport class Roster {\n    players;\n    constructor(data) {\n        this.players = this.parseRosterData(data);\n    }\n    parseRosterData(data) {\n        const roster = {};\n        for (const p of data.players) {\n            roster[p.id] = new Player(p);\n        }\n        return roster;\n    }\n    getPlayer(playerId) {\n        return this.players[playerId];\n    }\n    getAllPlayers() {\n        return this.players;\n    }\n}\nclass RosterStatsVisualizer {\n    roster;\n    parent;\n    header = null;\n    footer = null;\n    dataRows = null;\n    generalButton = null;\n    skillsButton = null;\n    tbody = null;\n    onGeneralPage = true;\n    minHeaderCell = null;\n    maxHeaderCell = null;\n    selectElement = null;\n    sortColumn = null;\n    sortAscending = true;\n    constructor(roster, parentNode) {\n        this.roster = roster;\n        this.parent = parentNode;\n        this.initialize();\n    }\n    initialize() {\n        const tabButtons = this.parent.querySelectorAll(`.btn-toggle`);\n        if (!tabButtons.length)\n            return;\n        const isGeneral = tabButtons[0]?.textContent?.trim() === \"General\";\n        this.generalButton = isGeneral ? tabButtons[0] : tabButtons[1];\n        this.skillsButton = isGeneral ? tabButtons[1] : tabButtons[0];\n        this.onGeneralPage = this.generalButton.classList.contains(\"active\");\n        // this.skillsButton =\n        this.generalButton.addEventListener(\"click\", async (event) => {\n            if (this.onGeneralPage)\n                return;\n            this.onGeneralPage = true;\n            // re-initialize the table references since dom has changed\n            this.initializeTableReferences();\n            if (this.dataRows && Object.keys(this.dataRows).length > 0) {\n                this.addNewColumns();\n            }\n            // if (this.sortColumn) this.sortRows()\n        });\n        this.skillsButton.addEventListener(\"click\", (event) => {\n            if (!this.onGeneralPage)\n                return;\n            this.onGeneralPage = false;\n            this.initializeTableReferences();\n            // if (this.sortColumn) this.sortRows();\n        });\n        this.selectElement = this.parent.querySelector(`select[value]`);\n        this.selectElement?.addEventListener(\"input\", () => {\n            this.initializeTableReferences();\n            this.addNewColumns();\n        });\n        // initialize table references and add columns on first load\n        this.initializeTableReferences();\n        if (this.dataRows && Object.keys(this.dataRows).length > 0) {\n            this.addNewColumns();\n        }\n    }\n    initializeTableReferences() {\n        // reset references to get the latest dom nodes\n        this.header = this.parent.querySelector(`table thead tr`);\n        this.footer = this.parent.querySelector(`table tfoot tr`);\n        this.tbody = this.parent.querySelector(\"table tbody\");\n        const headerElements = this.header?.querySelectorAll(`th`);\n        headerElements?.forEach((node) => node.addEventListener(\"click\", () => {\n            this.sortColumn = null;\n            this.sortAscending = false;\n        }));\n        const rows = this.parent.querySelectorAll(`tbody tr`);\n        const dr = {};\n        rows.forEach((row) => {\n            const tableRow = row;\n            const playerLink = tableRow.querySelector(\"a.player-link\");\n            if (playerLink?.getAttribute(\"href\")) {\n                const playerId = playerLink.getAttribute(\"href\").split(\"/\").pop() || \"\";\n                dr[playerId] = tableRow;\n            }\n        });\n        this.dataRows = dr;\n    }\n    getRosterAvgOvr(ovrType) {\n        const playerOvr = {\n            Default: (player) => player.getOvr(),\n            Min: (player) => player.getMinOvr(),\n            Max: (player) => player.getMaxOvr(),\n        };\n        const players = this.roster.getAllPlayers();\n        const values = Object.values(players)\n            .filter((player) => !player.getIsScout() || player.getOvr())\n            .map((player) => playerOvr[ovrType](player));\n        console.log(values);\n        return values.length\n            ? Math.round(values.reduce((sum, value, _, array) => sum + value / array.length, 0))\n            : 0;\n    }\n    createRatingSpan(ovr, scout) {\n        const ratingSpan = document.createElement(\"span\");\n        if (scout && !ovr) {\n            ratingSpan.classList.add(\"question-mark\");\n            ratingSpan.innerText = \"?\";\n            ratingSpan.style.color = \"#bcbabe\";\n        }\n        else {\n            ratingSpan.classList.add(\"badge\");\n            if (window.userData) {\n                ratingSpan.style.color = window.userData.getColorPair(ovr)[1];\n            }\n            ratingSpan.style.userSelect = \"none\";\n            if (window.userData) {\n                const [bgColor, color] = window.userData.getColorPair(ovr);\n                ratingSpan.style.backgroundColor = bgColor;\n                ratingSpan.style.color = color;\n            }\n            ratingSpan.innerText = ovr.toString();\n        }\n        return ratingSpan;\n    }\n    // private getRowPlayerName(row: HTMLTableRowElement): [string, string] {\n    //   const fullName = row\n    //     .querySelector(`a.player-link span`)\n    //     ?.textContent?.trim();\n    //   const [firstname = \"\", lastname = \"\"] = fullName?.split(\" \") ?? [];\n    //   return [firstname, lastname];\n    // }\n    // private addSorting(): void {\n    //   if (!this.minHeaderCell || !this.maxHeaderCell) return;\n    //   // min ovr sorting\n    //   this.minHeaderCell.addEventListener(\"click\", () => {\n    //     if (this.sortColumn === \"min-ovr\") {\n    //       // if already sorting by this column, toggle direction\n    //       this.sortAscending = !this.sortAscending;\n    //     } else {\n    //       this.sortColumn = \"min-ovr\";\n    //       this.sortAscending = false; // default descending\n    //     }\n    //     this.sortRows();\n    //   });\n    //   // max ovr sorting\n    //   this.maxHeaderCell.addEventListener(\"click\", () => {\n    //     if (this.sortColumn === \"max-ovr\") {\n    //       this.sortAscending = !this.sortAscending;\n    //     } else {\n    //       this.sortColumn = \"max-ovr\";\n    //       this.sortAscending = false;\n    //     }\n    //     this.sortRows();\n    //   });\n    // }\n    // private sortRows(): void {\n    //   if (!this.dataRows || !this.sortColumn || !this.tbody) return;\n    //   const tbody = this.tbody;\n    //   const rows = Object.entries(this.dataRows).map(([playerId, row]) => {\n    //     const player = this.roster.getPlayer(playerId);\n    //     const ovrValue = player\n    //       ? this.sortColumn === \"min-ovr\"\n    //         ? player.getMinOvr()\n    //         : player.getMaxOvr()\n    //       : 0;\n    //     const [firstName, lastName] = this.getRowPlayerName(row);\n    //     return {\n    //       row,\n    //       ovrValue,\n    //       firstName,\n    //       lastName,\n    //       playerId,\n    //     };\n    //   });\n    //   const collator = new Intl.Collator(undefined, {\n    //     usage: \"sort\",\n    //     sensitivity: \"base\",\n    //   });\n    //   rows.sort((a, b) => {\n    //     if (a.ovrValue !== b.ovrValue) {\n    //       return this.sortAscending\n    //         ? a.ovrValue - b.ovrValue\n    //         : b.ovrValue - a.ovrValue;\n    //     }\n    //     const lastNameCompare = collator.compare(a.lastName, b.lastName);\n    //     if (lastNameCompare !== 0) {\n    //       return this.sortAscending ? lastNameCompare : -lastNameCompare;\n    //     }\n    //     return this.sortAscending\n    //       ? collator.compare(a.firstName, b.firstName)\n    //       : collator.compare(b.firstName, a.firstName);\n    //   });\n    //   rows.forEach((item) => {\n    //     tbody.appendChild(item.row);\n    //   });\n    // }\n    addNewColumns() {\n        if (!this.onGeneralPage || !this.dataRows || !this.header || !this.footer)\n            return;\n        // delete old columns\n        this.parent\n            .querySelectorAll(`[data-column]`)\n            .forEach((node) => node.remove());\n        Object.entries(this.dataRows).forEach(([playerId, row]) => {\n            const player = this.roster.getPlayer(playerId);\n            if (!player)\n                return;\n            const minDataCell = document.createElement(\"td\");\n            minDataCell.className = \"md:px-4 px-2 py-2 text-center\";\n            minDataCell.dataset.column = \"min-ovr\";\n            minDataCell.appendChild(this.createRatingSpan(player.getMinOvr(), player.getIsScout()));\n            const maxDataCell = document.createElement(\"td\");\n            maxDataCell.className = \"md:px-4 px-2 py-2 text-center\";\n            maxDataCell.dataset.column = \"max-ovr\";\n            maxDataCell.appendChild(this.createRatingSpan(player.getMaxOvr(), player.getIsScout()));\n            row.insertBefore(minDataCell, null);\n            row.insertBefore(maxDataCell, null);\n        });\n        this.minHeaderCell = document.createElement(\"th\");\n        this.minHeaderCell.className = \"md:px-4 px-2 py-2 text-left sort-column\";\n        this.minHeaderCell.innerText = \" Min \";\n        this.minHeaderCell.style.textAlign = \"center\";\n        this.minHeaderCell.dataset.column = \"min-ovr\";\n        this.maxHeaderCell = document.createElement(\"th\");\n        this.maxHeaderCell.className = \"md:px-4 px-2 py-2 text-left sort-column\";\n        this.maxHeaderCell.innerText = \" Max \";\n        this.maxHeaderCell.style.textAlign = \"center\";\n        this.maxHeaderCell.dataset.column = \"max-ovr\";\n        this.header.insertBefore(this.minHeaderCell, null);\n        this.header.insertBefore(this.maxHeaderCell, null);\n        const minFooterCell = document.createElement(\"td\");\n        minFooterCell.className = \"md:px-4 px-2 py-2\";\n        minFooterCell.dataset.column = \"min-ovr\";\n        minFooterCell.appendChild(this.createRatingSpan(this.getRosterAvgOvr(\"Min\"), false));\n        const maxFooterCell = document.createElement(\"td\");\n        maxFooterCell.className = \"md:px-4 px-2 py-2\";\n        maxFooterCell.dataset.column = \"max-ovr\";\n        maxFooterCell.appendChild(this.createRatingSpan(this.getRosterAvgOvr(\"Max\"), false));\n        this.footer.insertBefore(minFooterCell, null);\n        this.footer.insertBefore(maxFooterCell, null);\n        // this.addSorting();\n    }\n}\nexport function handleRosterData(data) {\n    window.rosterData = new Roster(data);\n    const event = new CustomEvent(\"rosterDataReady\");\n    window.dispatchEvent(event);\n}\nexport function manipulateRosterPage(table) {\n    if (window.rosterData) {\n        new RosterStatsVisualizer(window.rosterData, table);\n    }\n    else {\n        const handler = () => {\n            new RosterStatsVisualizer(window.rosterData, table);\n            window.removeEventListener(\"rosterDataReady\", handler);\n        };\n        window.addEventListener(\"rosterDataReady\", handler);\n    }\n}\n","/*\nThis could be improved by also intercepting calls to settings api, and updating colors in the class as the user updates them\nThis is because the settings object isn't sent again after colors are updated, making class colors slightly outdated\nIs resolved on a refresh though\n*/\nexport class User {\n    \"bg-color-rating-90plus\" = \"#383839\";\n    \"bg-color-rating-85plus\" = \"#383839\";\n    \"bg-color-rating-80plus\" = \"#383839\";\n    \"bg-color-rating-75plus\" = \"#10b981\";\n    \"bg-color-rating-70plus\" = \"#10b981\";\n    \"bg-color-rating-65plus\" = \"#1995AD\";\n    \"bg-color-rating-60plus\" = \"#1995AD\";\n    \"bg-color-rating-55plus\" = \"#1995AD\";\n    \"bg-color-rating-50plus\" = \"#ed8936\";\n    \"bg-color-rating-45plus\" = \"#ed8936\";\n    \"bg-color-rating-40plus\" = \"#ed8936\";\n    \"bg-color-rating-40less\" = \"#f56565\";\n    \"color-rating-90plus\" = \"#f8f8f9\";\n    \"color-rating-85plus\" = \"#f8f8f9\";\n    \"color-rating-80plus\" = \"#f8f8f9\";\n    \"color-rating-75plus\" = \"#f8f8f9\";\n    \"color-rating-70plus\" = \"#f8f8f9\";\n    \"color-rating-65plus\" = \"#f8f8f9\";\n    \"color-rating-60plus\" = \"#f8f8f9\";\n    \"color-rating-55plus\" = \"#f8f8f9\";\n    \"color-rating-50plus\" = \"#f8f8f9\";\n    \"color-rating-45plus\" = \"#f8f8f9\";\n    \"color-rating-40plus\" = \"#f8f8f9\";\n    \"color-rating-40less\" = \"#f8f8f9\";\n    constructor(data) {\n        data && data?.settings && this.loadFromConfig(data.settings);\n    }\n    loadFromConfig(config) {\n        for (const { id, value } of config) {\n            if (id in this) {\n                this[id] = value;\n            }\n        }\n    }\n    getColorPair(rating) {\n        const thresholds = [90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40];\n        const matched = thresholds.find((t) => rating >= t);\n        const suffix = matched !== undefined ? `${matched}plus` : \"40less\";\n        const bgKey = `bg-color-rating-${suffix}`;\n        const colorKey = `color-rating-${suffix}`;\n        return [this[bgKey], this[colorKey]];\n    }\n}\nexport function handleUserData(data) {\n    window.userData = new User(data);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { handlePlayerData } from \"./pages/player\";\nimport { initNavigationHandler } from \"./navigation-handler\";\nimport { handleRosterData } from \"./pages/roster\";\nimport { handleUserData, User } from \"./user\";\n(function () {\n    initNavigationHandler(); // Initialize Observer from script context\n    window.userData = new User(); // Initialize User Object with default settings, probably not needed but fixes some load inconsistencies\n    const URL_HANDLERS = {\n        player: {\n            pattern: /\\/api\\/player\\/[^\\/]+$/,\n            handler: (data) => {\n                handlePlayerData(data.data);\n            },\n        },\n        roster: {\n            pattern: /\\/api\\/team\\/[^\\/]+\\/roster/,\n            handler: (data) => {\n                handleRosterData(data.data);\n            },\n        },\n        draftClass: {\n            pattern: /\\/api\\/league\\/[^\\/]+\\/draft-class/,\n            handler: (data, url) => {\n                console.log(data);\n                console.log(url);\n            },\n        },\n        userInfo: {\n            pattern: /\\/api\\/user$/,\n            handler: (data) => {\n                handleUserData(data);\n            },\n        },\n    };\n    function findHandler(url) {\n        for (const { pattern, handler } of Object.values(URL_HANDLERS)) {\n            if (pattern.test(url))\n                return handler;\n        }\n        return null;\n    }\n    class Interceptor extends XMLHttpRequest {\n        interceptedUrl = null;\n        // @ts-ignore\n        open(method, url, ...rest) {\n            this.interceptedUrl = url;\n            // @ts-ignore\n            super.open(method, url, ...rest);\n        }\n        send(...args) {\n            const url = this.interceptedUrl ?? \"\";\n            const handler = findHandler(this.interceptedUrl ?? \"\");\n            if (handler) {\n                const originalOnReadyState = this.onreadystatechange;\n                this.onreadystatechange = function () {\n                    if (this.readyState === 4 && this.status === 200) {\n                        try {\n                            const data = JSON.parse(this.responseText);\n                            handler(data, url);\n                        }\n                        catch (e) {\n                            console.error(\"Error parsing response:\", e);\n                        }\n                    }\n                    if (originalOnReadyState) {\n                        // @ts-ignore\n                        originalOnReadyState.apply(this, arguments);\n                    }\n                };\n            }\n            super.send(...args);\n        }\n    }\n    window.XMLHttpRequest = Interceptor;\n    // intercept fetch as well, although I don't think this is used\n    const originalFetch = window.fetch;\n    window.fetch = async function (resource, init) {\n        // handle strings & request obj\n        const url = typeof resource === \"string\"\n            ? resource\n            : resource instanceof Request\n                ? resource.url\n                : resource.toString();\n        const response = await originalFetch.call(this, resource, init);\n        const handler = url && findHandler(url);\n        if (handler) {\n            try {\n                const clonedResponse = response.clone();\n                const data = await clonedResponse.json();\n                handler(data, url);\n            }\n            catch (e) {\n                console.error(\"Error processing fetch response:\", e);\n            }\n        }\n        return response;\n    };\n})();\n"],"names":[],"sourceRoot":""}