{"version":3,"file":"interceptor.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCzIA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNqD;;AAErD;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAgB;AACxB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://hockeynation/./src/pages/player.ts","webpack://hockeynation/webpack/bootstrap","webpack://hockeynation/webpack/runtime/define property getters","webpack://hockeynation/webpack/runtime/hasOwnProperty shorthand","webpack://hockeynation/webpack/runtime/make namespace object","webpack://hockeynation/./src/interceptor.js"],"sourcesContent":["function parsePlayerData(data) {\n    const player = {};\n    player.stats = {};\n    player.scout = data.data.skills.some((skill) => skill?.hidden ?? false);\n    for (const s of data.data.skills) {\n        player.stats[s.id] = {\n            rating: parseInt(s?.lvl ?? 0),\n            max: s?.max ?? false,\n            strength: null, // default, change below\n        };\n    }\n    if (data.data?.talents?.weakest) {\n        // if weakness exists so does strength\n        player.stats[data.data.talents.weakest].strength = \"weakest\";\n        data.data.talents.strongest.forEach((str) => (player.stats[str].strength = \"strongest\"));\n    }\n    return player;\n}\nfunction calcMinStats(stats) {\n    const minStats = structuredClone(stats);\n    let weakestRating = 10;\n    let highestNonStrongestRating = 0;\n    // update ratings and find the highest non-strongest rating\n    for (const stat of Object.values(minStats)) {\n        stat.rating = stat.max ? stat.rating : stat.rating + 1;\n        if (stat.strength !== \"strongest\") {\n            highestNonStrongestRating = Math.max(highestNonStrongestRating, stat.rating);\n        }\n    }\n    // find the weakest rating\n    for (const stat of Object.values(minStats)) {\n        if (stat.strength === \"weakest\") {\n            weakestRating = stat.rating;\n        }\n    }\n    // adjust strongest stats\n    for (const stat of Object.values(minStats)) {\n        if (stat.strength === \"strongest\" &&\n            stat.rating < highestNonStrongestRating) {\n            stat.rating = highestNonStrongestRating;\n        }\n    }\n    // adjust weakest stats\n    for (const stat of Object.values(minStats)) {\n        if (stat.rating < weakestRating) {\n            stat.rating = weakestRating;\n        }\n        if (stat.rating < 4) {\n            stat.rating = 4;\n        }\n    }\n    return minStats;\n}\nfunction calcMaxStats(stats) {\n    const maxStats = structuredClone(stats);\n    let strongestRating = 10;\n    let lowestNonWeakestRating = 10;\n    // find the strongest rating\n    for (const stat of Object.values(maxStats)) {\n        if (stat.strength === \"strongest\") {\n            strongestRating = Math.min(strongestRating, stat.max ? stat.rating : 10);\n        }\n    }\n    // update ratings and find the lowest non-weakest rating\n    for (const stat of Object.values(maxStats)) {\n        if (!stat.max && stat.rating < strongestRating) {\n            stat.rating = strongestRating;\n        }\n        if (stat.strength !== \"weakest\") {\n            lowestNonWeakestRating = Math.min(lowestNonWeakestRating, stat.rating);\n        }\n    }\n    // adjust strongest stats\n    for (const stat of Object.values(maxStats)) {\n        if (stat.strength === \"strongest\" && !stat.max && stat.rating < 10) {\n            stat.rating = 10;\n        }\n    }\n    // adjust weakest stats\n    for (const stat of Object.values(maxStats)) {\n        if (stat.strength === \"weakest\" && stat.rating > lowestNonWeakestRating) {\n            stat.rating = lowestNonWeakestRating;\n        }\n        if (stat.rating < 4) {\n            stat.rating = 4;\n        }\n    }\n    return maxStats;\n}\nfunction insertDropdown(div) {\n    const dropdown = document.createElement(\"select\");\n    dropdown.classList.add(\"stats-dropdown\");\n    dropdown.style.marginLeft = \"auto\";\n    dropdown.style.fontSize = \"12px\";\n    dropdown.style.padding = \"2px\";\n    dropdown.style.border = \"none\";\n    dropdown.style.backgroundColor = \"#fff\";\n    dropdown.style.color = \"#000\";\n    dropdown.style.width = \"85px\";\n    dropdown.style.height = \"18px\";\n    dropdown.style.lineHeight = \"18px\";\n    dropdown.style.paddingTop = \"0px\";\n    dropdown.style.paddingBottom = \"0px\";\n    dropdown.style.paddingRight = \"21px\";\n    dropdown.style.borderRadius = \"2px\";\n    dropdown.addEventListener(\"change\", (event) => {\n        const selectElement = event.target;\n        const selectedOption = selectElement.value;\n        // updateHockeyPucks(selectedOption);\n    });\n    const options = [\"Default\", \"Min\", \"Max\"];\n    options.forEach((option) => {\n        const optionElement = document.createElement(\"option\");\n        optionElement.value = option;\n        optionElement.textContent = option;\n        optionElement.style.textAlign = \"center\";\n        dropdown.appendChild(optionElement);\n    });\n    div.appendChild(dropdown);\n}\nfunction checkPageLoad() {\n    const div = Array.from(document.querySelectorAll(\"div.card-header\")).filter((d) => d?.textContent?.trim() === \"Skills\")?.[0];\n    if (div) {\n        insertDropdown(div);\n        return;\n    }\n    requestAnimationFrame(checkPageLoad);\n}\nexport function handlePlayerData(data) {\n    // I just naturally assumed that the player request would only be used on the player page...\n    // This is probably true but this will be left in until I confirm or refactor the handler\n    if (!window.location.href.startsWith(\"https://hockey-nation.com/player\"))\n        return;\n    const player = parsePlayerData(data);\n    const minStats = calcMinStats(player.stats);\n    const maxStats = calcMaxStats(player.stats);\n    requestAnimationFrame(checkPageLoad);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { handlePlayerData } from \"./pages/player.ts\";\n\n(function () {\n  const URL_HANDLERS = {\n    player: {\n      pattern: /\\/api\\/player\\/[^\\/]+$/,\n      handler: (data) => {\n        handlePlayerData(data);\n      },\n    },\n    roster: {\n      pattern: /\\/api\\/team\\/[^\\/]+\\/roster/,\n      handler: (data) => {\n        console.log(\"Found roster data:\", data);\n      },\n    },\n  };\n\n  function findHandler(url) {\n    for (const { pattern, handler } of Object.values(URL_HANDLERS)) {\n      if (pattern.test(url)) return handler;\n    }\n    return null;\n  }\n\n  // intercept XHR\n  const originalOpen = XMLHttpRequest.prototype.open;\n  const originalSend = XMLHttpRequest.prototype.send;\n\n  XMLHttpRequest.prototype.open = function (method, url, ...rest) {\n    this._interceptedUrl = url;\n    return originalOpen.apply(this, arguments);\n  };\n\n  XMLHttpRequest.prototype.send = function (...args) {\n    let handler;\n    if (this._interceptedUrl && (handler = findHandler(this._interceptedUrl))) {\n      const originalOnReadyState = this.onreadystatechange;\n\n      this.onreadystatechange = function () {\n        if (this.readyState === 4 && this.status === 200) {\n          try {\n            const data = JSON.parse(this.responseText);\n            handler(data);\n          } catch (e) {\n            console.error(\"Error parsing response:\", e);\n          }\n        }\n\n        if (originalOnReadyState) {\n          originalOnReadyState.apply(this, arguments);\n        }\n      };\n    }\n\n    return originalSend.apply(this, args);\n  };\n\n  // intercept fetch as well, although I don't think this is used\n  const originalFetch = window.fetch;\n  window.fetch = async function (resource, init) {\n    // handle strings & request obj\n    const url = typeof resource === \"string\" ? resource : resource.url;\n    const response = await originalFetch.apply(this, arguments);\n\n    let handler;\n    if (url && (handler = findHandler(url))) {\n      try {\n        const clonedResponse = response.clone();\n        const data = await clonedResponse.json();\n        handler(data);\n      } catch (e) {\n        console.error(\"Error processing fetch response:\", e);\n      }\n    }\n    return response;\n  };\n})();\n"],"names":[],"sourceRoot":""}