{"version":3,"file":"interceptor.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChBqD;AACU;AACI;AACb;AACA;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAoB;AAChC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,mEAAoB;AAChC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,4EAAwB;AACpC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,gFAA0B;AACtC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAe;AACnB;AACA;AACA,QAAQ,8DAAe;AACvB;AACA;;;;;;;;;;;;;;;ACzDO;AACP;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvDkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,4CAA4C;AAC5C,yCAAyC;AACzC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,SAAS;AACT;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,SAAS;AAC9E;AACA;AACA,gEAAgE;AAChE;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB,0BAA0B,2CAAM;AAChC;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;AC7MkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,2CAAM,GAAG,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3H8D;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;;;;;;;;;;;;;;;;;;AC1WkC;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2CAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;AChTA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D,yCAAyC,OAAO;AAChD,yCAAyC,OAAO;AAChD;AACA;AACA;AACO;AACP;AACA;;;;;;;UCnDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;ACNkD;AACW;AACX;AACJ;AACa;AACI;AAC/D;AACA,IAAI,0EAAqB,IAAI;AAC7B,0BAA0B,uCAAI,IAAI;AAClC;AACA;AACA;AACA;AACA,gBAAgB,+DAAgB;AAChC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,+DAAgB;AAChC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,wEAAoB;AACpC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,qDAAc;AAC9B,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,4EAAsB;AACtC,aAAa;AACb,SAAS;AACT;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://hockeynation/./src/mappings/skill-mappings.ts","webpack://hockeynation/./src/navigation-handler.ts","webpack://hockeynation/./src/observer-handler.ts","webpack://hockeynation/./src/pages/draft-class.ts","webpack://hockeynation/./src/pages/draft-ranking.ts","webpack://hockeynation/./src/pages/player.ts","webpack://hockeynation/./src/pages/roster.ts","webpack://hockeynation/./src/user.ts","webpack://hockeynation/webpack/bootstrap","webpack://hockeynation/webpack/runtime/define property getters","webpack://hockeynation/webpack/runtime/hasOwnProperty shorthand","webpack://hockeynation/webpack/runtime/make namespace object","webpack://hockeynation/./src/interceptor.ts"],"sourcesContent":["export const SKILL_NAME_TO_ID = {\n    Skating: \"SKA\",\n    Reflexes: \"REF\",\n    Endurance: \"END\",\n    Power: \"PWR\",\n    Positioning: \"POS\",\n    Shooting: \"SHO\",\n    Pads: \"PAD\",\n    Passing: \"PAS\",\n    Glove: \"GLO\",\n    Defending: \"DEF\",\n    Blocker: \"BLO\",\n    Checking: \"CHK\",\n    Stick: \"STK\",\n    Discipline: \"DSC\",\n    Faceoffs: \"FOF\",\n};\n","import { ObserverManager } from \"./observer-handler\";\nimport { manipulateDraftClassPage } from \"./pages/draft-class\";\nimport { manipulateDraftRankingPage } from \"./pages/draft-ranking\";\nimport { manipulatePlayerPage } from \"./pages/player\";\nimport { manipulateRosterPage } from \"./pages/roster\";\nconst PAGE_HANDLERS = {\n    player: {\n        url: \"https://hockey-nation.com/player\",\n        selector: \"table tbody tr\",\n        handler: (el) => {\n            manipulatePlayerPage(el);\n        },\n    },\n    roster: {\n        url: \"https://hockey-nation.com/club/roster\",\n        selector: \"table tbody tr\",\n        handler: (el) => {\n            manipulateRosterPage(el);\n        },\n    },\n    draftClass: {\n        url: \"https://hockey-nation.com/office/draft-center\",\n        selector: \".stats-container\",\n        handler: (el) => {\n            manipulateDraftClassPage(el);\n        },\n    },\n    draftRanking: {\n        url: \"https://hockey-nation.com/draft-ranking\",\n        selector: \"table tbody tr\",\n        handler: (el) => {\n            manipulateDraftRankingPage(el);\n        },\n    },\n};\nfunction findPageHandler(url) {\n    for (const page of Object.values(PAGE_HANDLERS)) {\n        if (url.startsWith(page.url)) {\n            return page;\n        }\n    }\n    return null;\n}\nexport function initNavigationHandler() {\n    handleNavigation();\n    // @ts-ignore\n    window.navigation.addEventListener(\"currententrychange\", handleNavigation);\n}\nfunction handleNavigation() {\n    const url = window.location.href;\n    const pageHandler = findPageHandler(url);\n    // reset previous observer\n    ObserverManager.getInstance().resetCallback();\n    // set new callback if we have a handler for the page\n    if (pageHandler) {\n        ObserverManager.getInstance().setCallback(pageHandler.selector, pageHandler.handler);\n    }\n}\n","export class ObserverManager {\n    static instance;\n    observer = null;\n    currentSelector = null;\n    currentCallback = null;\n    constructor() { } //singleton\n    static getInstance() {\n        if (!ObserverManager.instance) {\n            ObserverManager.instance = new ObserverManager();\n        }\n        return ObserverManager.instance;\n    }\n    setCallback(selector, callback) {\n        this.currentSelector = selector;\n        this.currentCallback = callback;\n        this.ensureObserverActive();\n    }\n    resetCallback() {\n        this.currentSelector = null;\n        this.currentCallback = null;\n    }\n    ensureObserverActive() {\n        if (!this.observer) {\n            this.observer = new MutationObserver((mutations) => {\n                const currentSelector = this.currentSelector;\n                const currentCallback = this.currentCallback;\n                if (!currentSelector || !currentCallback)\n                    return;\n                mutations.forEach((mutation) => {\n                    if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n                        mutation.addedNodes.forEach((node) => {\n                            if (node.nodeType === Node.ELEMENT_NODE) {\n                                const element = node;\n                                const target = element.querySelector(currentSelector);\n                                if (target) {\n                                    currentCallback(element);\n                                    this.disconnect();\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n            this.observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n    disconnect() {\n        if (this.observer) {\n            this.observer.disconnect();\n            this.observer = null;\n        }\n    }\n}\n","import { Roster } from \"./roster\";\nclass DraftClassVisualizer {\n    parent = null;\n    draftClass = null;\n    draftCards = null;\n    toggleButtonListener = null;\n    paginationButtonListeners = new Map();\n    selectMenuListeners = new Map();\n    mutationObserver = null;\n    observerTimeoutId = null;\n    constructor() { }\n    attach(el) {\n        this.detach(); // clean up any previous state/listeners\n        this.parent = el;\n        if (this.parent && this.draftClass) {\n            this.initializeDOMReferences(); // Find cards within the new parent\n            this.attachEventListeners(); // Add listeners within the new parent scope\n            this.addBadges(); // Add badges based on current data/DOM\n        }\n    }\n    detach() {\n        if (!this.parent)\n            return;\n        const toggleButton = document.querySelectorAll(`.btn-toggle`)[1];\n        if (toggleButton && this.toggleButtonListener) {\n            toggleButton.removeEventListener(\"click\", this.toggleButtonListener);\n            this.toggleButtonListener = null;\n        }\n        // remove pagination listeners\n        this.paginationButtonListeners.forEach((listener, button) => {\n            button.removeEventListener(\"click\", listener);\n        });\n        this.paginationButtonListeners.clear();\n        // remove select menu listeners and observer\n        this.selectMenuListeners.forEach((listener, select) => {\n            select.removeEventListener(\"change\", listener);\n        });\n        this.selectMenuListeners.clear();\n        this.disconnectObserver(); // disconnect observer if active\n        this.parent = null;\n        this.draftCards = null;\n    }\n    updateData(newData) {\n        this.draftClass = newData;\n        if (this.parent) {\n            this.initializeDOMReferences();\n            this.addBadges();\n        }\n    }\n    initializeDOMReferences() {\n        if (!this.parent)\n            return;\n        const rows = this.parent.querySelectorAll(\"[id^='draftee-card']\");\n        const dc = {};\n        rows.forEach((row) => {\n            const card = row;\n            const playerLink = card.querySelector(`a[href^='/player/']`);\n            const badge = card.querySelector(\".badge\"); // needed by addBadges later\n            if (!playerLink || !badge)\n                return;\n            const playerId = playerLink.getAttribute(\"href\")?.split(\"/\").pop();\n            if (playerId) {\n                dc[playerId] = card;\n            }\n        });\n        this.draftCards = dc;\n    }\n    attachEventListeners() {\n        if (!this.parent)\n            return;\n        const toggleButton = document.querySelectorAll(`.btn-toggle`)[1];\n        if (toggleButton) {\n            this.toggleButtonListener = () => {\n                this.initializeDOMReferences();\n                this.addBadges();\n            };\n            toggleButton.addEventListener(\"click\", this.toggleButtonListener);\n        }\n        this.paginationButtonListeners.clear(); // clear map before adding\n        const buttons = Array.from(this.parent.querySelectorAll(\"button\")).filter((btn) => {\n            const hasMatchingSpan = Array.from(btn.querySelectorAll(\"span\")).some((span) => /^(1|21|41|61|81)-\\d+$/.test(span.textContent?.trim() ?? \"\"));\n            const buttonText = Array.from(btn.childNodes)\n                .filter((node) => node.nodeType === Node.TEXT_NODE)\n                .map((node) => node.textContent?.trim())\n                .join(\"\");\n            const hasMatchingDirectText = /^(1|21|41|61|81)-\\d+$/.test(buttonText);\n            return hasMatchingSpan || hasMatchingDirectText;\n        });\n        buttons.forEach((button) => {\n            const listener = () => {\n                this.initializeDOMReferences();\n                this.addBadges();\n            };\n            button.addEventListener(\"click\", listener);\n            this.paginationButtonListeners.set(button, listener); // store for removal\n        });\n        this.selectMenuListeners.clear();\n        this.parent.querySelectorAll(\"select\").forEach((menu) => {\n            const listener = () => {\n                this.disconnectObserver(); // disconnect previous observer\n                this.mutationObserver = new MutationObserver((mutations) => {\n                    const hasRelevantChanges = mutations.some((mutation) => mutation.addedNodes.length > 0 &&\n                        Array.from(mutation.addedNodes).some((node) => node.nodeType === Node.ELEMENT_NODE &&\n                            node.querySelector('[id^=\"draftee-card\"]')));\n                    if (hasRelevantChanges) {\n                        this.initializeDOMReferences();\n                        this.addBadges();\n                        this.disconnectObserver();\n                    }\n                });\n                this.mutationObserver.observe(this.parent, {\n                    childList: true,\n                    subtree: true,\n                });\n                if (this.observerTimeoutId)\n                    clearTimeout(this.observerTimeoutId);\n                this.observerTimeoutId = window.setTimeout(() => {\n                    this.disconnectObserver();\n                }, 3000); // 3 seconds\n            };\n            menu.addEventListener(\"change\", listener);\n            this.selectMenuListeners.set(menu, listener);\n        });\n    }\n    disconnectObserver() {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n            this.mutationObserver = null;\n        }\n        if (this.observerTimeoutId) {\n            clearTimeout(this.observerTimeoutId);\n            this.observerTimeoutId = null;\n        }\n    }\n    addBadges() {\n        // Adds Min/Max badges to draft cards\n        if (!this.draftCards || !this.draftClass) {\n            console.warn(\"Cannot add badges: Missing draft cards or draft class data.\");\n            return;\n        }\n        console.log(\"Adding/updating badges...\");\n        let badgesAddedCount = 0;\n        Object.entries(this.draftCards).forEach(([playerId, card]) => {\n            // //safety\n            if (card.getAttribute(\"data-ovr-badges-added\") === \"true\")\n                return;\n            const badgeContainer = card.querySelector(`.badge`)?.parentElement;\n            if (!badgeContainer) {\n                console.warn(`Badge container not found for player ${playerId}`);\n                return;\n            }\n            const player = this.draftClass.getPlayer(playerId); // draftClass checked above\n            if (!player) {\n                console.warn(`Player data not found for ${playerId} in draft class.`);\n                return;\n            }\n            badgeContainer\n                .querySelectorAll(\".dynamic-ovr-label, .dynamic-ovr-badge\")\n                .forEach((el) => el.remove());\n            // Add MIN\n            badgeContainer.appendChild(this.createOvrLabelSpan(\"MIN\"));\n            badgeContainer.appendChild(this.createRatingSpan(player.getMinOvr()));\n            // Add MAX\n            badgeContainer.appendChild(this.createOvrLabelSpan(\"MAX\"));\n            badgeContainer.appendChild(this.createRatingSpan(player.getMaxOvr()));\n            card.setAttribute(\"data-ovr-badges-added\", \"true\");\n            badgesAddedCount++;\n        });\n    }\n    createOvrLabelSpan(text) {\n        const label = document.createElement(\"span\");\n        // add a class to make it easier to remove later\n        label.classList.add(\"dynamic-ovr-label\", \"uppercase\", \"ml-3\", \"xs:inline-block\", \"hidden\");\n        label.innerText = text;\n        return label;\n    }\n    createRatingSpan(ovr) {\n        const ratingSpan = document.createElement(\"span\");\n        // add a class to make it easier to remove later\n        ratingSpan.classList.add(\"dynamic-ovr-badge\", \"badge\", \"ml-1\");\n        ratingSpan.style.userSelect = \"none\";\n        if (window.userData &&\n            typeof window.userData.getColorPair === \"function\" &&\n            ovr > 0) {\n            try {\n                const [bgColor, color] = window.userData.getColorPair(ovr);\n                ratingSpan.style.backgroundColor = bgColor;\n                ratingSpan.style.color = color;\n            }\n            catch (e) {\n                console.error(\"Error getting color pair for OVR:\", ovr, e);\n            }\n        }\n        ratingSpan.innerText = ovr > 0 ? ovr.toString() : \"?\"; // Show ? if OVR is 0, shouldn't ever be needed\n        return ratingSpan;\n    }\n}\nconst draftVisualizerInstance = new DraftClassVisualizer();\nexport function handleDraftClassData(data) {\n    const rosterData = { ...data, players: data.draftees };\n    const newRoster = new Roster(rosterData);\n    draftVisualizerInstance.updateData(newRoster);\n}\nexport function manipulateDraftClassPage(el) {\n    draftVisualizerInstance.attach(el);\n}\n","import { Roster } from \"./roster\";\nlet visualizerInstance = null;\nclass DraftRankingVisualizer {\n    parent;\n    draftRanking = null;\n    draftCards = null;\n    ovrTab = null;\n    tableHR = null;\n    constructor(el) {\n        this.parent = el;\n        window.addEventListener(\"draftRankingDataUpdated\", this.onDataUpdated.bind(this));\n        if (window.draftRankingData) {\n            this.draftRanking = window.draftRankingData;\n            this.initialize();\n        }\n    }\n    onDataUpdated() {\n        if (window.draftRankingData) {\n            this.draftRanking = window.draftRankingData;\n            this.initializeReferences();\n        }\n    }\n    initialize() {\n        this.initializeReferences();\n    }\n    initializeReferences() {\n        if (!this.draftRanking)\n            return;\n        this.tableHR = this.parent.querySelector(`table thead tr`);\n        if (!this.tableHR)\n            return;\n        this.ovrTab =\n            Array.from(this.tableHR.querySelectorAll(`th span`)).filter((span) => span.textContent?.trim() === \"OVR\")?.[0]?.parentElement ?? null;\n        if (!this.ovrTab)\n            return;\n        const rows = this.parent.querySelectorAll(`table tbody tr`);\n        const dc = {};\n        rows.forEach((row) => {\n            const tableRow = row;\n            const playerLink = tableRow.querySelectorAll(`a`)[1];\n            if (playerLink?.getAttribute(\"href\")) {\n                const playerId = playerLink.getAttribute(\"href\").split(\"/\").pop() || \"\";\n                dc[playerId] = tableRow;\n            }\n        });\n        this.draftCards = dc;\n        console.log(this.draftCards);\n        this.addRows();\n    }\n    addRows() {\n        if (!this.tableHR || !this.ovrTab || !this.draftCards)\n            return;\n        const tabElement = this.ovrTab;\n        const headerRow = tabElement.parentElement;\n        if (!headerRow)\n            return;\n        const ovrIdx = Array.from(headerRow.children).indexOf(tabElement);\n        const minHeader = this.createOvrLabelSpan(\"MIN\");\n        const maxHeader = this.createOvrLabelSpan(\"MAX\");\n        this.tableHR.insertBefore(maxHeader, this.ovrTab.nextSibling);\n        this.tableHR.insertBefore(minHeader, this.ovrTab.nextSibling);\n        Object.entries(this.draftCards).forEach(([playerId, row]) => {\n            const player = this.draftRanking?.getPlayer(playerId);\n            if (!player)\n                return;\n            const minDataCell = document.createElement(\"td\");\n            minDataCell.className = \"px-4 text-center\";\n            minDataCell.appendChild(this.createRatingSpan(player.getMinOvr()));\n            const maxDataCell = document.createElement(\"td\");\n            maxDataCell.className = \"px-4 text-center\";\n            maxDataCell.appendChild(this.createRatingSpan(player.getMaxOvr()));\n            row.insertBefore(maxDataCell, row.children[ovrIdx]);\n            row.insertBefore(minDataCell, row.children[ovrIdx]);\n        });\n    }\n    createOvrLabelSpan(text) {\n        const header = document.createElement(\"th\");\n        header.classList.add(\"px-4\", \"py-2\");\n        header.innerHTML = `<span>${text}</span>`;\n        return header;\n    }\n    // modify to include empty fields\n    createRatingSpan(ovr) {\n        const ratingSpan = document.createElement(\"span\");\n        if (!ovr) {\n            ratingSpan.innerText = \"-\";\n            ratingSpan.style.color = \"#555456\";\n            ratingSpan.style.textAlign = \"center\";\n        }\n        else {\n            ratingSpan.classList.add(\"badge\");\n            ratingSpan.style.userSelect = \"none\";\n            if (window.userData) {\n                ratingSpan.style.backgroundColor = window.userData.getColorPair(ovr)[0];\n                ratingSpan.style.color = window.userData.getColorPair(ovr)[1];\n            }\n            ratingSpan.innerText = ovr.toString();\n        }\n        return ratingSpan;\n    }\n}\nexport function handleDraftRankingData(data) {\n    const isUpdate = !!window.draftRankingData;\n    window.draftRankingData = new Roster({ players: data });\n    const eventName = isUpdate\n        ? \"draftRankingDataUpdated\"\n        : \"draftRankingDataReady\";\n    const event = new CustomEvent(eventName);\n    window.dispatchEvent(event);\n}\nexport function manipulateDraftRankingPage(el) {\n    if (!visualizerInstance) {\n        if (window.draftRankingData) {\n            visualizerInstance = new DraftRankingVisualizer(el);\n        }\n        else {\n            const handler = () => {\n                visualizerInstance = new DraftRankingVisualizer(el);\n                window.removeEventListener(\"draftRankingDataReady\", handler);\n            };\n            window.addEventListener(\"draftRankingDataReady\", handler);\n        }\n    }\n}\n","import { SKILL_NAME_TO_ID } from \"../mappings/skill-mappings\";\nexport class Player {\n    stats;\n    minStats;\n    maxStats;\n    isScout;\n    ovr;\n    minOvr;\n    maxOvr;\n    constructor(data) {\n        const player = this.parsePlayerData(data);\n        this.stats = player.stats;\n        this.isScout = player.scout;\n        this.minStats = this.calcMinStats(this.stats);\n        this.maxStats = this.calcMaxStats(this.stats);\n        this.ovr = data?.rating ?? 0;\n        this.minOvr = this.calculateOVR(this.minStats);\n        this.maxOvr = this.calculateOVR(this.maxStats);\n    }\n    parsePlayerData(data) {\n        const player = {};\n        player.stats = {};\n        player.scout = data.skills.every((skill) => skill?.hidden ?? false);\n        for (const s of data.skills) {\n            player.stats[s.id] = {\n                rating: parseInt(s?.lvl ?? 0),\n                max: s?.max ?? false,\n                strength: null, // default, change below\n            };\n        }\n        if (data?.talents?.weakest) {\n            // if weakness exists so does strength\n            player.stats[data.talents.weakest].strength = \"weakest\";\n            data.talents.strongest.forEach((str) => (player.stats[str].strength =\n                \"strongest\"));\n        }\n        return player;\n    }\n    calcMinStats(stats) {\n        const minStats = structuredClone(stats);\n        let weakestRating = 10;\n        let highestNonStrongestRating = 0;\n        // update ratings and find the highest non-strongest rating\n        for (const stat of Object.values(minStats)) {\n            stat.rating = stat.max ? stat.rating : stat.rating + 1;\n            if (stat.strength !== \"strongest\") {\n                highestNonStrongestRating = Math.max(highestNonStrongestRating, stat.rating);\n            }\n        }\n        // find the weakest rating\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"weakest\") {\n                weakestRating = stat.rating;\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"strongest\" &&\n                stat.rating < highestNonStrongestRating) {\n                stat.rating = highestNonStrongestRating;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.rating < weakestRating) {\n                stat.rating = weakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return minStats;\n    }\n    calcMaxStats(stats) {\n        const maxStats = structuredClone(stats);\n        let strongestRating = 10;\n        let lowestNonWeakestRating = 10;\n        // find the strongest rating\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\") {\n                strongestRating = Math.min(strongestRating, stat.max ? stat.rating : 10);\n            }\n        }\n        // update ratings and find the lowest non-weakest rating\n        for (const stat of Object.values(maxStats)) {\n            if (!stat.max && stat.rating < strongestRating) {\n                stat.rating = strongestRating;\n            }\n            if (stat.strength !== \"weakest\") {\n                lowestNonWeakestRating = Math.min(lowestNonWeakestRating, stat.rating);\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\" && !stat.max && stat.rating < 10) {\n                stat.rating = 10;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"weakest\" && stat.rating > lowestNonWeakestRating) {\n                stat.rating = lowestNonWeakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return maxStats;\n    }\n    getStats() {\n        return this.stats;\n    }\n    getMinStats() {\n        return this.minStats;\n    }\n    getMaxStats() {\n        return this.maxStats;\n    }\n    getIsScout() {\n        return this.isScout;\n    }\n    getOvr() {\n        return this.ovr;\n    }\n    getMaxOvr() {\n        return Math.max(this.maxOvr, this.ovr); // handles cases where ovr is known through scouting, but stats are unknown\n    }\n    getMinOvr() {\n        return Math.max(this.minOvr, this.ovr);\n    }\n    calculateOVR(stats) {\n        if (this.isScout)\n            return 0;\n        const statsValues = Object.values(stats);\n        const sum = statsValues.reduce((acc, stat) => acc + stat.rating, 0);\n        const avg = sum / statsValues.length;\n        const excess = statsValues.reduce((acc, stat) => stat.rating > avg ? acc + stat.rating - avg : acc, 0);\n        const correctedSum = sum + excess;\n        const correctedAverage = correctedSum / statsValues.length;\n        return Math.round(correctedAverage * 10);\n    }\n}\nclass PlayerStatsVisualizer {\n    playerStats = null;\n    parentNode = null;\n    ovrElement = null;\n    statsTable = null;\n    statsRows = null;\n    skillsHeaderDiv = null;\n    dropdownElement = null;\n    dropdownListener = null; // store listeners\n    constructor() { }\n    attach(el, playerData) {\n        this.detach(); // clean up previous state first\n        if (!playerData)\n            return;\n        this.parentNode = el;\n        this.playerStats = playerData;\n        if (!this.initializeDOMReferences()) {\n            this.detach(); // clean up if initialization failed\n            return;\n        }\n        this.attachUIAndListeners();\n        this.updateHockeyPucks(\"Default\");\n    }\n    detach() {\n        if (!this.parentNode)\n            return;\n        if (this.dropdownElement && this.dropdownListener) {\n            this.dropdownElement.removeEventListener(\"change\", this.dropdownListener);\n        }\n        if (this.dropdownElement && this.dropdownElement.parentNode) {\n            this.dropdownElement.parentNode.removeChild(this.dropdownElement);\n        }\n        this.parentNode = null;\n        this.playerStats = null;\n        this.ovrElement = null;\n        this.statsTable = null;\n        this.statsRows = null;\n        this.skillsHeaderDiv = null;\n        this.dropdownElement = null;\n        this.dropdownListener = null;\n    }\n    initializeDOMReferences() {\n        if (!this.parentNode)\n            return false;\n        this.ovrElement =\n            this.parentNode.querySelector(\".polygon text\");\n        const puck = this.parentNode.querySelector(\"svg.fa-hockey-puck\");\n        this.statsTable = puck\n            ? puck.closest(`tbody`)\n            : null;\n        if (this.statsTable) {\n            this.statsRows =\n                this.statsTable.querySelectorAll(\"tr\");\n            if (!this.statsRows || this.statsRows.length === 0) {\n                return false; // critical\n            }\n        }\n        const headers = Array.from(this.parentNode.querySelectorAll(\".card-header\"));\n        this.skillsHeaderDiv = headers.find((d) => d?.textContent?.trim() === \"Skills\");\n        return !!(this.ovrElement || this.statsTable);\n    }\n    attachUIAndListeners() {\n        if (!this.skillsHeaderDiv)\n            return;\n        if (this.skillsHeaderDiv.querySelector(\".stats-dropdown-player\"))\n            return; // safety\n        this.dropdownElement = document.createElement(\"select\");\n        this.dropdownElement.classList.add(\"stats-dropdown-player\");\n        this.dropdownElement.style.marginLeft = \"auto\";\n        this.dropdownElement.style.fontSize = \"12px\";\n        this.dropdownElement.style.padding = \"2px\";\n        this.dropdownElement.style.border = \"none\";\n        this.dropdownElement.style.backgroundColor = \"#fff\";\n        this.dropdownElement.style.color = \"#000\";\n        this.dropdownElement.style.width = \"85px\";\n        this.dropdownElement.style.height = \"18px\";\n        this.dropdownElement.style.lineHeight = \"18px\";\n        this.dropdownElement.style.paddingTop = \"0px\";\n        this.dropdownElement.style.paddingBottom = \"0px\";\n        this.dropdownElement.style.paddingRight = \"21px\";\n        this.dropdownElement.style.borderRadius = \"2px\";\n        // store the listener function\n        this.dropdownListener = (event) => {\n            const selectElement = event.target;\n            const selectedOption = selectElement.value;\n            this.updateHockeyPucks(selectedOption);\n        };\n        this.dropdownElement.addEventListener(\"change\", this.dropdownListener);\n        const options = [\"Default\", \"Min\", \"Max\"];\n        options.forEach((option) => {\n            const optionElement = document.createElement(\"option\");\n            optionElement.value = option;\n            optionElement.textContent = option;\n            optionElement.style.textAlign = \"center\";\n            this.dropdownElement.appendChild(optionElement);\n        });\n        this.skillsHeaderDiv.appendChild(this.dropdownElement);\n    }\n    updateHockeyPucks(option) {\n        if (!this.statsRows || !this.playerStats)\n            return;\n        const statsToUse = option === \"Min\"\n            ? this.playerStats.getMinStats()\n            : option === \"Max\"\n                ? this.playerStats.getMaxStats()\n                : this.playerStats.getStats();\n        if (!statsToUse)\n            return;\n        this.statsRows.forEach((row) => {\n            const skillNameText = row.cells[0]?.textContent?.trim();\n            if (!skillNameText)\n                return;\n            const statName = SKILL_NAME_TO_ID[skillNameText];\n            if (!statName)\n                return;\n            const pucksCell = row.cells[1];\n            const ratingCell = row.cells[2];\n            if (!pucksCell || !ratingCell)\n                return;\n            const pucks = pucksCell.querySelectorAll(\"svg.fa-hockey-puck\");\n            const ratingSpan = ratingCell.querySelector(\"span\");\n            // need base stats for comparison\n            const baseStats = this.playerStats.getStats(); // playerStats is checked above\n            const baseStat = baseStats ? baseStats[statName] : null;\n            const displayStat = statsToUse[statName];\n            if (baseStat && displayStat && pucks.length > 0) {\n                pucks.forEach((puck, index) => {\n                    puck.classList.remove(\"text-blue-400\");\n                    if (index < displayStat.rating) {\n                        puck.classList.remove(\"text-gray-300\");\n                        if (index >= baseStat.rating) {\n                            puck.classList.add(\"text-blue-400\");\n                        }\n                    }\n                    else {\n                        puck.classList.add(\"text-gray-300\");\n                    }\n                    if (index === displayStat.rating - 1 && baseStat.max) {\n                        puck.classList.add(\"max-level\");\n                    }\n                    else {\n                        puck.classList.remove(\"max-level\");\n                    }\n                });\n                if (ratingSpan) {\n                    ratingSpan.textContent = `(${displayStat.rating})`;\n                }\n            }\n        });\n        if (!this.playerStats)\n            return;\n        const ovr = option === \"Min\"\n            ? this.playerStats.getMinOvr()\n            : option === \"Max\"\n                ? this.playerStats.getMaxOvr()\n                : this.playerStats.getOvr();\n        // confirm scout logic later\n        let ovrToShow = ovr;\n        if (option === \"Default\" &&\n            this.playerStats.getIsScout() &&\n            this.playerStats.getOvr() > 0) {\n            ovrToShow = this.playerStats.getOvr();\n        }\n        // only update if we have a valid number (Min/Max calc returns 0 for scouts)\n        // or if it's default view for a scout with known OVR\n        if (ovrToShow > 0 ||\n            (option === \"Default\" &&\n                this.playerStats.getIsScout() &&\n                this.playerStats.getOvr() > 0)) {\n            this.updateOVR(ovrToShow);\n        }\n        else if (option !== \"Default\" && this.playerStats.getIsScout()) {\n            // Handle displaying Min/Max for a scout where calculation is 0\n            this.updateOVR(this.playerStats.getOvr()); // show default OVR as fallback?\n        }\n        else {\n            // fallback to default OVR if other conditions aren't met\n            this.updateOVR(this.playerStats.getOvr());\n        }\n    }\n    updateOVR(ovr) {\n        if (!this.ovrElement)\n            return;\n        this.ovrElement.textContent = ovr > 0 ? ovr.toString() : \"?\"; // Show ? if OVR is 0, though in practice this should never happen\n        const polygonElement = this.ovrElement.parentElement?.querySelector(\"polygon\");\n        if (polygonElement && ovr > 0) {\n            // only color if OVR > 0\n            if (window.userData &&\n                typeof window.userData.getColorPair === \"function\") {\n                try {\n                    const [bgColor, color] = window.userData.getColorPair(ovr);\n                    polygonElement.setAttribute(\"fill\", bgColor);\n                    this.ovrElement.setAttribute(\"fill\", color);\n                }\n                catch (e) {\n                    console.error(\"Failed to get color pair for OVR:\", ovr, e);\n                }\n            }\n        }\n    }\n}\nconst playerVisualizerInstance = new PlayerStatsVisualizer();\nexport function handlePlayerData(data) {\n    window.playerData = new Player(data);\n    const event = new CustomEvent(\"playerDataReady\");\n    window.dispatchEvent(event);\n}\nexport function manipulatePlayerPage(el) {\n    // ensure the singleton instance exists\n    if (window.playerData) {\n        playerVisualizerInstance.attach(el, window.playerData);\n    }\n    else {\n        const handler = () => {\n            // check instance again in case of race conditions? unlikely but possible\n            playerVisualizerInstance.attach(el, window.playerData); // data ready\n            window.removeEventListener(\"playerDataReady\", handler);\n        };\n        window.addEventListener(\"playerDataReady\", handler, { once: true });\n    }\n}\n","import { Player } from \"./player\";\nexport class Roster {\n    players;\n    constructor(data) {\n        this.players = this.parseRosterData(data);\n    }\n    parseRosterData(data) {\n        const roster = {};\n        for (const p of data.players) {\n            roster[p.id] = new Player(p);\n        }\n        return roster;\n    }\n    getPlayer(playerId) {\n        return this.players[playerId];\n    }\n    getAllPlayers() {\n        return this.players;\n    }\n}\nclass RosterStatsVisualizer {\n    roster = null;\n    parent = null;\n    header = null;\n    footer = null;\n    dataRows = null;\n    tbody = null;\n    onGeneralPage = true;\n    minHeaderCell = null;\n    maxHeaderCell = null;\n    sortColumn = null;\n    sortAscending = true;\n    // store bound listeners for easier removal\n    generalButtonClickListener = null;\n    skillsButtonClickListener = null;\n    selectChangeListener = null;\n    headerClickListeners = new Map();\n    constructor() { }\n    attach(el) {\n        this.detach();\n        this.parent = el;\n        if (this.parent && this.roster) {\n            this.initializeVisualizerState();\n            this.initializeTableReferences();\n            this.attachEventListeners();\n            this.renderColumns();\n            // if (this.sortColumn) this.sortRows();\n        }\n        else {\n            // cleanup if attachment is incomplete\n            this.detach();\n        }\n    }\n    detach() {\n        if (!this.parent)\n            return;\n        const tabButtons = this.parent.querySelectorAll(`.btn-toggle`);\n        if (tabButtons.length >= 2) {\n            const isGeneral = tabButtons[0]?.textContent?.trim() === \"General\";\n            const generalButton = isGeneral ? tabButtons[0] : tabButtons[1];\n            const skillsButton = isGeneral ? tabButtons[1] : tabButtons[0];\n            if (this.generalButtonClickListener && generalButton)\n                generalButton.removeEventListener(\"click\", this.generalButtonClickListener);\n            if (this.skillsButtonClickListener && skillsButton)\n                skillsButton.removeEventListener(\"click\", this.skillsButtonClickListener);\n        }\n        const selectElement = this.parent.querySelector(`select[value]`);\n        if (this.selectChangeListener && selectElement)\n            selectElement.removeEventListener(\"input\", this.selectChangeListener);\n        this.headerClickListeners.forEach((listener, th) => {\n            th.removeEventListener(\"click\", listener);\n        });\n        this.headerClickListeners.clear();\n        this.parent\n            .querySelectorAll(`[data-column]`)\n            .forEach((node) => node.remove());\n        this.parent = null;\n        this.header = null;\n        this.footer = null;\n        this.dataRows = null;\n        this.tbody = null;\n        this.minHeaderCell = null;\n        this.maxHeaderCell = null;\n        this.generalButtonClickListener = null;\n        this.skillsButtonClickListener = null;\n        this.selectChangeListener = null;\n    }\n    updateRoster(newRoster) {\n        this.roster = newRoster;\n        if (this.parent && this.roster) {\n            this.initializeTableReferences();\n            this.renderColumns();\n            // if (this.sortColumn) this.sortRows();\n        }\n    }\n    initializeVisualizerState() {\n        if (!this.parent)\n            return;\n        const tabButtons = this.parent.querySelectorAll(`.btn-toggle`);\n        if (!tabButtons.length || tabButtons.length < 2) {\n            this.onGeneralPage = true;\n            return;\n        }\n        const isGeneral = tabButtons[0]?.textContent?.trim() === \"General\";\n        const generalButton = isGeneral ? tabButtons[0] : tabButtons[1];\n        this.onGeneralPage = generalButton?.classList.contains(\"active\") ?? true;\n    }\n    initializeTableReferences() {\n        if (!this.parent)\n            return;\n        this.header = this.parent.querySelector(`table thead tr`);\n        this.footer = this.parent.querySelector(`table tfoot tr`);\n        this.tbody = this.parent.querySelector(\"table tbody\");\n        this.dataRows = {}; // reset row references\n        if (!this.tbody)\n            return;\n        const rows = this.tbody.querySelectorAll(`tr`);\n        rows.forEach((row) => {\n            const tableRow = row;\n            const playerLink = tableRow.querySelector(\"a.player-link\");\n            const href = playerLink?.getAttribute(\"href\");\n            if (href) {\n                const playerId = href.split(\"/\").pop() || \"\";\n                if (playerId) {\n                    this.dataRows[playerId] = tableRow;\n                }\n            }\n        });\n    }\n    attachEventListeners() {\n        if (!this.parent)\n            return;\n        const tabButtons = this.parent.querySelectorAll(`.btn-toggle`);\n        if (tabButtons.length === 2) {\n            const isGeneral = tabButtons[0]?.textContent?.trim() === \"General\";\n            const generalButton = isGeneral ? tabButtons[0] : tabButtons[1];\n            const skillsButton = isGeneral ? tabButtons[1] : tabButtons[0];\n            // store the bound function to remove it later\n            this.generalButtonClickListener = () => {\n                if (this.onGeneralPage)\n                    return;\n                this.onGeneralPage = true;\n                // re-initialize references and render columns for the new state\n                this.initializeTableReferences();\n                this.renderColumns();\n                // if (this.sortColumn) this.sortRows();\n            };\n            if (generalButton)\n                generalButton.addEventListener(\"click\", this.generalButtonClickListener);\n            this.skillsButtonClickListener = () => {\n                if (!this.onGeneralPage)\n                    return;\n                this.onGeneralPage = false;\n                this.initializeTableReferences();\n                this.renderColumns(); // remove columns as we are not on general page\n                // if (this.sortColumn) this.sortRows();\n            };\n            if (skillsButton)\n                skillsButton.addEventListener(\"click\", this.skillsButtonClickListener);\n        }\n        const selectElement = this.parent.querySelector(`select[value]`);\n        if (selectElement) {\n            this.selectChangeListener = () => {\n                this.initializeTableReferences();\n                this.renderColumns();\n                // if (this.sortColumn) this.sortRows();\n            };\n            selectElement.addEventListener(\"input\", this.selectChangeListener);\n        }\n        // clear any stale listeners first (though detach should handle this)\n        this.headerClickListeners.forEach((listener, th) => th.removeEventListener(\"click\", listener));\n        this.headerClickListeners.clear();\n        // add listeners to existing TH elements (not the dynamic min/max ones yet)\n        this.header?.querySelectorAll(`th`).forEach((th) => {\n            // safety check\n            if (!th.hasAttribute(\"data-column\")) {\n                const listener = () => {\n                    this.sortColumn = null;\n                    this.sortAscending = false;\n                    // Potentially update header styles (remove arrows) if sort indicators are used\n                    // Potentially re-sort rows to default if needed\n                };\n                th.addEventListener(\"click\", listener);\n                this.headerClickListeners.set(th, listener); // stored for removal\n            }\n        });\n        // NOTE: Listeners for dynamically added Min/Max header cells\n        // should be added within `renderColumns` after the cells are created.\n    }\n    renderColumns() {\n        if (!this.parent ||\n            !this.roster ||\n            !this.dataRows ||\n            !this.header ||\n            !this.footer) {\n            return;\n        }\n        // remove previously added dynamic columns and their header/footer cells\n        this.parent\n            .querySelectorAll(`[data-column]`)\n            .forEach((node) => node.remove());\n        // TODO: Remove sorting listeners specifically attached to old min/max headers if sorting is added\n        this.minHeaderCell = null; // reset references\n        this.maxHeaderCell = null;\n        // add columns ONLY if on the General Page ---\n        if (!this.onGeneralPage)\n            return;\n        Object.entries(this.dataRows).forEach(([playerId, row]) => {\n            const player = this.roster.getPlayer(playerId);\n            if (!player)\n                return;\n            const minDataCell = document.createElement(\"td\");\n            minDataCell.className = \"md:px-4 px-2 py-2 text-center\";\n            minDataCell.dataset.column = \"min-ovr\";\n            minDataCell.appendChild(this.createRatingSpan(player.getMinOvr(), player.getIsScout()));\n            const maxDataCell = document.createElement(\"td\");\n            maxDataCell.className = \"md:px-4 px-2 py-2 text-center\";\n            maxDataCell.dataset.column = \"max-ovr\";\n            maxDataCell.appendChild(this.createRatingSpan(player.getMaxOvr(), player.getIsScout()));\n            // append to the end of the row\n            row.appendChild(minDataCell);\n            row.appendChild(maxDataCell);\n        });\n        //header\n        this.minHeaderCell = document.createElement(\"th\");\n        this.minHeaderCell.className = \"md:px-4 px-2 py-2 text-center sort-column\";\n        this.minHeaderCell.innerText = \" Min \";\n        this.minHeaderCell.dataset.column = \"min-ovr\";\n        // TODO: Add click listener here for sorting if implemented\n        // this.minHeaderCell.addEventListener('click', this.handleMinSortClick);\n        this.header.appendChild(this.minHeaderCell);\n        this.maxHeaderCell = document.createElement(\"th\");\n        this.maxHeaderCell.className = \"md:px-4 px-2 py-2 text-center sort-column\";\n        this.maxHeaderCell.innerText = \" Max \";\n        this.maxHeaderCell.dataset.column = \"max-ovr\";\n        // TODO: Add click listener here for sorting if implemented\n        // this.maxHeaderCell.addEventListener('click', this.handleMaxSortClick);\n        this.header.appendChild(this.maxHeaderCell);\n        // footer\n        const minFooterCell = document.createElement(\"td\");\n        minFooterCell.className = \"md:px-4 px-2 py-2 text-center\";\n        minFooterCell.dataset.column = \"min-ovr\";\n        minFooterCell.appendChild(this.createRatingSpan(this.getRosterAvgOvr(\"Min\"), false));\n        const maxFooterCell = document.createElement(\"td\");\n        maxFooterCell.className = \"md:px-4 px-2 py-2 text-center\";\n        maxFooterCell.dataset.column = \"max-ovr\";\n        maxFooterCell.appendChild(this.createRatingSpan(this.getRosterAvgOvr(\"Max\"), false));\n        this.footer.appendChild(minFooterCell);\n        this.footer.appendChild(maxFooterCell);\n    }\n    getRosterAvgOvr(ovrType) {\n        if (!this.roster)\n            return 0;\n        const playerOvr = {\n            Default: (player) => player.getOvr(),\n            Min: (player) => player.getMinOvr(),\n            Max: (player) => player.getMaxOvr(),\n        };\n        const players = this.roster.getAllPlayers();\n        if (!players)\n            return 0;\n        const values = Object.values(players)\n            .filter((player) => player && (!player.getIsScout() || player.getOvr() > 0)) // ensure player exists & filter scouts without OVR\n            .map((player) => playerOvr[ovrType](player));\n        return values.length\n            ? Math.round(values.reduce((sum, value, _, array) => sum + value / array.length, 0))\n            : 0;\n    }\n    createRatingSpan(ovr, scout) {\n        const ratingSpan = document.createElement(\"span\");\n        if (scout && (!ovr || ovr <= 0)) {\n            // treat 0 OVR for scout same as unknown\n            ratingSpan.classList.add(\"question-mark\");\n            ratingSpan.innerText = \"?\";\n            ratingSpan.style.color = \"#bcbabe\";\n            ratingSpan.style.textAlign = \"center\";\n        }\n        else {\n            ratingSpan.classList.add(\"badge\");\n            ratingSpan.style.userSelect = \"none\";\n            ratingSpan.innerText = ovr.toString();\n            if (window.userData &&\n                typeof window.userData.getColorPair === \"function\") {\n                try {\n                    const [bgColor, color] = window.userData.getColorPair(ovr);\n                    ratingSpan.style.backgroundColor = bgColor;\n                    ratingSpan.style.color = color;\n                }\n                catch (e) {\n                    console.error(\"Error getting color pair for OVR:\", ovr, e);\n                }\n            }\n        }\n        return ratingSpan;\n    }\n}\nconst rosterVisualizerInstance = new RosterStatsVisualizer();\nexport function handleRosterData(data) {\n    const newRoster = new Roster(data);\n    // notify the visualizer instance about the new data\n    rosterVisualizerInstance.updateRoster(newRoster);\n}\nexport function manipulateRosterPage(el) {\n    rosterVisualizerInstance.attach(el);\n}\n","/*\nThis could be improved by also intercepting calls to settings api, and updating colors in the class as the user updates them\nThis is because the settings object isn't sent again after colors are updated, making class colors slightly outdated\nIs resolved on a refresh though\n*/\nexport class User {\n    \"bg-color-rating-90plus\" = \"#383839\";\n    \"bg-color-rating-85plus\" = \"#383839\";\n    \"bg-color-rating-80plus\" = \"#383839\";\n    \"bg-color-rating-75plus\" = \"#10b981\";\n    \"bg-color-rating-70plus\" = \"#10b981\";\n    \"bg-color-rating-65plus\" = \"#1995AD\";\n    \"bg-color-rating-60plus\" = \"#1995AD\";\n    \"bg-color-rating-55plus\" = \"#1995AD\";\n    \"bg-color-rating-50plus\" = \"#ed8936\";\n    \"bg-color-rating-45plus\" = \"#ed8936\";\n    \"bg-color-rating-40plus\" = \"#ed8936\";\n    \"bg-color-rating-40less\" = \"#f56565\";\n    \"color-rating-90plus\" = \"#f8f8f9\";\n    \"color-rating-85plus\" = \"#f8f8f9\";\n    \"color-rating-80plus\" = \"#f8f8f9\";\n    \"color-rating-75plus\" = \"#f8f8f9\";\n    \"color-rating-70plus\" = \"#f8f8f9\";\n    \"color-rating-65plus\" = \"#f8f8f9\";\n    \"color-rating-60plus\" = \"#f8f8f9\";\n    \"color-rating-55plus\" = \"#f8f8f9\";\n    \"color-rating-50plus\" = \"#f8f8f9\";\n    \"color-rating-45plus\" = \"#f8f8f9\";\n    \"color-rating-40plus\" = \"#f8f8f9\";\n    \"color-rating-40less\" = \"#f8f8f9\";\n    constructor(data) {\n        data && data?.settings && this.loadFromConfig(data.settings);\n    }\n    loadFromConfig(config) {\n        for (const { id, value } of config) {\n            if (id in this) {\n                this[id] = value;\n            }\n        }\n    }\n    getColorPair(rating) {\n        const thresholds = [90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40];\n        const matched = thresholds.find((t) => rating >= t);\n        const suffix = matched !== undefined ? `${matched}plus` : \"40less\";\n        const bgKey = `bg-color-rating-${suffix}`;\n        const colorKey = `color-rating-${suffix}`;\n        return [this[bgKey], this[colorKey]];\n    }\n}\nexport function handleUserData(data) {\n    window.userData = new User(data);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { handlePlayerData } from \"./pages/player\";\nimport { initNavigationHandler } from \"./navigation-handler\";\nimport { handleRosterData } from \"./pages/roster\";\nimport { handleUserData, User } from \"./user\";\nimport { handleDraftClassData } from \"./pages/draft-class\";\nimport { handleDraftRankingData } from \"./pages/draft-ranking\";\n(function () {\n    initNavigationHandler(); // Initialize Observer from script context\n    window.userData = new User(); // Initialize User Object with default settings, probably not needed but fixes some load inconsistencies\n    const URL_HANDLERS = {\n        player: {\n            pattern: /\\/api\\/player\\/[^\\/]+$/,\n            handler: (data) => {\n                handlePlayerData(data.data);\n            },\n        },\n        roster: {\n            pattern: /\\/api\\/team\\/[^\\/]+\\/roster/,\n            handler: (data) => {\n                handleRosterData(data.data);\n            },\n        },\n        draftClass: {\n            pattern: /\\/api\\/league\\/[^\\/]+\\/draft-class/,\n            handler: (data) => {\n                handleDraftClassData(data.data);\n            },\n        },\n        userInfo: {\n            pattern: /\\/api\\/user$/,\n            handler: (data) => {\n                handleUserData(data);\n            },\n        },\n        draftRanking: {\n            pattern: /\\/api\\/draft\\/[^\\/]+\\/rankings/,\n            handler: (data) => {\n                handleDraftRankingData(data.data);\n            },\n        },\n    };\n    function findHandler(url) {\n        for (const { pattern, handler } of Object.values(URL_HANDLERS)) {\n            if (pattern.test(url))\n                return handler;\n        }\n        return null;\n    }\n    class Interceptor extends XMLHttpRequest {\n        interceptedUrl = null;\n        // @ts-ignore\n        open(method, url, ...rest) {\n            this.interceptedUrl = url;\n            // @ts-ignore\n            super.open(method, url, ...rest);\n        }\n        send(...args) {\n            const url = this.interceptedUrl ?? \"\";\n            const handler = findHandler(this.interceptedUrl ?? \"\");\n            if (handler) {\n                const originalOnReadyState = this.onreadystatechange;\n                this.onreadystatechange = function () {\n                    if (this.readyState === 4 && this.status === 200) {\n                        try {\n                            const data = JSON.parse(this.responseText);\n                            handler(data);\n                        }\n                        catch (e) {\n                            console.error(\"Error parsing response:\", e);\n                        }\n                    }\n                    if (originalOnReadyState) {\n                        // @ts-ignore\n                        originalOnReadyState.apply(this, arguments);\n                    }\n                };\n            }\n            super.send(...args);\n        }\n    }\n    window.XMLHttpRequest = Interceptor;\n    // intercept fetch as well, although I don't think this is used\n    const originalFetch = window.fetch;\n    window.fetch = async function (resource, init) {\n        // handle strings & request obj\n        const url = typeof resource === \"string\"\n            ? resource\n            : resource instanceof Request\n                ? resource.url\n                : resource.toString();\n        const response = await originalFetch.call(this, resource, init);\n        const handler = url && findHandler(url);\n        if (handler) {\n            try {\n                const clonedResponse = response.clone();\n                const data = await clonedResponse.json();\n                handler(data);\n            }\n            catch (e) {\n                console.error(\"Error processing fetch response:\", e);\n            }\n        }\n        return response;\n    };\n})();\n"],"names":[],"sourceRoot":""}