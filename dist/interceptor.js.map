{"version":3,"file":"interceptor.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChBqD;AACC;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAoB;AAChC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,+BAA+B;AAC/B,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAe;AACnB;AACA;AACA,QAAQ,8DAAe;AACvB;AACA;;;;;;;;;;;;;;;ACtCO;AACP;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtD8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCzSA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNqD;AACQ;;AAE7D;AACA,EAAE,0EAAqB,IAAI;;AAE3B;AACA;AACA;AACA;AACA,QAAQ,kEAAgB;AACxB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://hockeynation/./src/mappings/skill-mappings.ts","webpack://hockeynation/./src/navigation-handler.ts","webpack://hockeynation/./src/observer-handler.ts","webpack://hockeynation/./src/pages/player.ts","webpack://hockeynation/webpack/bootstrap","webpack://hockeynation/webpack/runtime/define property getters","webpack://hockeynation/webpack/runtime/hasOwnProperty shorthand","webpack://hockeynation/webpack/runtime/make namespace object","webpack://hockeynation/./src/interceptor.js"],"sourcesContent":["export const SKILL_NAME_TO_ID = {\n    Skating: \"SKA\",\n    Reflexes: \"REF\",\n    Endurance: \"END\",\n    Power: \"PWR\",\n    Positioning: \"POS\",\n    Shooting: \"SHO\",\n    Pads: \"PAD\",\n    Passing: \"PAS\",\n    Glove: \"GLO\",\n    Defending: \"DEF\",\n    Blocker: \"BLO\",\n    Checking: \"CHK\",\n    Stick: \"STK\",\n    Discipline: \"DSC\",\n    Faceoffs: \"FOF\",\n};\n","import { ObserverManager } from \"./observer-handler\";\nimport { manipulatePlayerPage } from \"./pages/player\";\nconst PAGE_HANDLERS = {\n    player: {\n        url: \"https://hockey-nation.com/player/\",\n        selector: \"table[data-v-a81c915e]\",\n        handler: (table) => {\n            manipulatePlayerPage(table);\n        },\n    },\n    // roster: {\n    //   url: \"https://hockey-nation.com/club/roster/\",\n    //   selector: \"\", //TBD\n    //   handler: (table) => {},\n    // },\n};\nfunction findPageHandler(url) {\n    for (const page of Object.values(PAGE_HANDLERS)) {\n        if (url.startsWith(page.url)) {\n            return page;\n        }\n    }\n    return null;\n}\nexport function initNavigationHandler() {\n    handleNavigation();\n    // @ts-ignore\n    window.navigation.addEventListener(\"currententrychange\", handleNavigation);\n}\nfunction handleNavigation() {\n    const url = window.location.href;\n    const pageHandler = findPageHandler(url);\n    // reset previous observer\n    ObserverManager.getInstance().resetCallback();\n    // set new callback if we have a handler for the page\n    if (pageHandler) {\n        ObserverManager.getInstance().setCallback(pageHandler.selector, pageHandler.handler);\n    }\n}\n","export class ObserverManager {\n    static instance;\n    observer = null;\n    currentSelector = null;\n    currentCallback = null;\n    constructor() { } //singleton\n    static getInstance() {\n        if (!ObserverManager.instance) {\n            ObserverManager.instance = new ObserverManager();\n        }\n        return ObserverManager.instance;\n    }\n    setCallback(selector, callback) {\n        this.currentSelector = selector;\n        this.currentCallback = callback;\n        this.ensureObserverActive();\n    }\n    resetCallback() {\n        this.currentSelector = null;\n        this.currentCallback = null;\n    }\n    ensureObserverActive() {\n        if (!this.observer) {\n            this.observer = new MutationObserver((mutations) => {\n                const currentSelector = this.currentSelector;\n                const currentCallback = this.currentCallback;\n                if (!currentSelector || !currentCallback)\n                    return;\n                mutations.forEach((mutation) => {\n                    if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n                        mutation.addedNodes.forEach((node) => {\n                            if (node.nodeType === Node.ELEMENT_NODE) {\n                                const element = node;\n                                const target = element.querySelector(currentSelector);\n                                if (target) {\n                                    currentCallback(element);\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n            this.observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n    disconnect() {\n        if (this.observer) {\n            this.observer.disconnect();\n            this.observer = null;\n        }\n    }\n}\n","import { SKILL_NAME_TO_ID } from \"../mappings/skill-mappings\";\nclass PlayerStats {\n    stats;\n    minStats;\n    maxStats;\n    isScout;\n    constructor(data) {\n        const player = this.parsePlayerData(data);\n        this.stats = player.stats;\n        this.isScout = player.scout;\n        this.minStats = this.calcMinStats(this.stats);\n        this.maxStats = this.calcMaxStats(this.stats);\n    }\n    parsePlayerData(data) {\n        const player = {};\n        player.stats = {};\n        player.scout = data.data.skills.some((skill) => skill?.hidden ?? false);\n        for (const s of data.data.skills) {\n            player.stats[s.id] = {\n                rating: parseInt(s?.lvl ?? 0),\n                max: s?.max ?? false,\n                strength: null, // default, change below\n            };\n        }\n        if (data.data?.talents?.weakest) {\n            // if weakness exists so does strength\n            player.stats[data.data.talents.weakest].strength = \"weakest\";\n            data.data.talents.strongest.forEach((str) => (player.stats[str].strength =\n                \"strongest\"));\n        }\n        return player;\n    }\n    calcMinStats(stats) {\n        const minStats = structuredClone(stats);\n        let weakestRating = 10;\n        let highestNonStrongestRating = 0;\n        // update ratings and find the highest non-strongest rating\n        for (const stat of Object.values(minStats)) {\n            stat.rating = stat.max ? stat.rating : stat.rating + 1;\n            if (stat.strength !== \"strongest\") {\n                highestNonStrongestRating = Math.max(highestNonStrongestRating, stat.rating);\n            }\n        }\n        // find the weakest rating\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"weakest\") {\n                weakestRating = stat.rating;\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.strength === \"strongest\" &&\n                stat.rating < highestNonStrongestRating) {\n                stat.rating = highestNonStrongestRating;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(minStats)) {\n            if (stat.rating < weakestRating) {\n                stat.rating = weakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return minStats;\n    }\n    calcMaxStats(stats) {\n        const maxStats = structuredClone(stats);\n        let strongestRating = 10;\n        let lowestNonWeakestRating = 10;\n        // find the strongest rating\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\") {\n                strongestRating = Math.min(strongestRating, stat.max ? stat.rating : 10);\n            }\n        }\n        // update ratings and find the lowest non-weakest rating\n        for (const stat of Object.values(maxStats)) {\n            if (!stat.max && stat.rating < strongestRating) {\n                stat.rating = strongestRating;\n            }\n            if (stat.strength !== \"weakest\") {\n                lowestNonWeakestRating = Math.min(lowestNonWeakestRating, stat.rating);\n            }\n        }\n        // adjust strongest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"strongest\" && !stat.max && stat.rating < 10) {\n                stat.rating = 10;\n            }\n        }\n        // adjust weakest stats\n        for (const stat of Object.values(maxStats)) {\n            if (stat.strength === \"weakest\" && stat.rating > lowestNonWeakestRating) {\n                stat.rating = lowestNonWeakestRating;\n            }\n            if (stat.rating < 4) {\n                stat.rating = 4;\n            }\n        }\n        return maxStats;\n    }\n    calculateOVR(stats) {\n        const statsValues = Object.values(stats);\n        const sum = statsValues.reduce((acc, stat) => acc + stat.rating, 0);\n        const avg = sum / statsValues.length;\n        const excess = statsValues.reduce((acc, stat) => stat.rating > avg ? acc + stat.rating - avg : acc, 0);\n        const correctedSum = sum + excess;\n        const correctedAverage = correctedSum / statsValues.length;\n        return Math.round(correctedAverage * 10);\n    }\n}\nclass StatsVisualizer {\n    playerStats;\n    parentNode;\n    ovrElement = null;\n    baseOVR = null;\n    statsTable = null;\n    statsRows = null;\n    constructor(playerStats, parentNode) {\n        this.playerStats = playerStats;\n        this.parentNode = parentNode;\n        this.initialize();\n    }\n    initialize() {\n        const puck = this.parentNode.querySelector(\"svg.fa-hockey-puck\");\n        if (!puck) {\n            return;\n        }\n        let ancestor = puck.parentElement;\n        while (ancestor && !ancestor.matches(\"table[data-v-a81c915e]\")) {\n            ancestor = ancestor.parentElement;\n        }\n        this.statsTable = ancestor;\n        if (!this.statsTable) {\n            return;\n        }\n        // get stats rows\n        this.statsRows =\n            this.statsTable.querySelectorAll(\"tbody tr\");\n        if (!this.statsRows.length) {\n            return;\n        }\n        // get OVR element\n        this.ovrElement = this.parentNode.querySelector(\"div.polygon.select-none text\");\n        this.baseOVR = this.ovrElement ? this.ovrElement.textContent : null;\n        // add dropdown to skills header\n        this.addDropdown();\n        // initialize display\n        this.updateHockeyPucks(\"Default\");\n    }\n    // Consider not adding / disabling twhen all of a player's stats are maxed\n    addDropdown() {\n        const div = Array.from(document.querySelectorAll(\"div.card-header\")).filter((d) => d?.textContent?.trim() === \"Skills\")?.[0];\n        if (div === undefined)\n            return;\n        if (div.querySelector(\".stats-dropdown\"))\n            return;\n        const dropdown = document.createElement(\"select\");\n        dropdown.classList.add(\"stats-dropdown\");\n        dropdown.style.marginLeft = \"auto\";\n        dropdown.style.fontSize = \"12px\";\n        dropdown.style.padding = \"2px\";\n        dropdown.style.border = \"none\";\n        dropdown.style.backgroundColor = \"#fff\";\n        dropdown.style.color = \"#000\";\n        dropdown.style.width = \"85px\";\n        dropdown.style.height = \"18px\";\n        dropdown.style.lineHeight = \"18px\";\n        dropdown.style.paddingTop = \"0px\";\n        dropdown.style.paddingBottom = \"0px\";\n        dropdown.style.paddingRight = \"21px\";\n        dropdown.style.borderRadius = \"2px\";\n        dropdown.addEventListener(\"change\", (event) => {\n            const selectElement = event.target;\n            const selectedOption = selectElement.value;\n            this.updateHockeyPucks(selectedOption);\n        });\n        const options = [\"Default\", \"Min\", \"Max\"];\n        options.forEach((option) => {\n            const optionElement = document.createElement(\"option\");\n            optionElement.value = option;\n            optionElement.textContent = option;\n            optionElement.style.textAlign = \"center\";\n            dropdown.appendChild(optionElement);\n        });\n        div.appendChild(dropdown);\n    }\n    updateHockeyPucks(option) {\n        if (!this.statsRows)\n            return;\n        const statsToUse = option === \"Min\"\n            ? this.playerStats.minStats\n            : option === \"Max\"\n                ? this.playerStats.maxStats\n                : this.playerStats.stats;\n        this.statsRows.forEach((row) => {\n            const statName = SKILL_NAME_TO_ID[row.cells[0]?.textContent?.trim() || \"\"];\n            const pucksCell = row.cells[1];\n            const pucks = pucksCell.querySelectorAll(\"svg.fa-hockey-puck\");\n            const ratingCell = row.cells[2];\n            const ratingSpan = ratingCell?.querySelector(\"span\");\n            const baseStat = this.playerStats.stats[statName];\n            const displayStat = statsToUse[statName];\n            if (baseStat && displayStat) {\n                pucks.forEach((puck, index) => {\n                    puck.classList.remove(\"text-blue-400\");\n                    if (index < displayStat.rating) {\n                        puck.classList.remove(\"text-gray-300\");\n                        if (index >= baseStat.rating) {\n                            puck.classList.add(\"text-blue-400\");\n                        }\n                    }\n                    else {\n                        puck.classList.add(\"text-gray-300\");\n                    }\n                    if (index === displayStat.rating - 1 && baseStat.max) {\n                        puck.classList.add(\"max-level\");\n                    }\n                    else {\n                        puck.classList.remove(\"max-level\");\n                    }\n                });\n                // update the rating value in the span element\n                if (ratingSpan) {\n                    ratingSpan.textContent = `(${displayStat.rating})`;\n                }\n            }\n        });\n        // update OVR\n        let ovr = this.playerStats.calculateOVR(statsToUse);\n        if (option !== \"Default\" || !this.playerStats.isScout) {\n            this.updateOVR(ovr);\n        }\n        else if (this.baseOVR !== null) {\n            this.updateOVR(parseInt(this.baseOVR));\n        }\n    }\n    updateOVR(ovr) {\n        if (!this.ovrElement)\n            return;\n        this.ovrElement.textContent = ovr.toString();\n        const polygonElement = this.ovrElement.parentElement?.querySelector(\"polygon\");\n        if (polygonElement) {\n            let fillColor = \"\";\n            if (ovr <= 39) {\n                fillColor = \"#f56565\";\n            }\n            else if (ovr >= 40 && ovr <= 54) {\n                fillColor = \"#ed8936\";\n            }\n            else if (ovr >= 55 && ovr <= 69) {\n                fillColor = \"#1995AD\";\n            }\n            else if (ovr >= 70 && ovr <= 79) {\n                fillColor = \"#10b981\";\n            }\n            else if (ovr >= 80) {\n                fillColor = \"#383839\";\n            }\n            polygonElement.setAttribute(\"fill\", fillColor);\n        }\n    }\n}\nfunction observerCallback(mutations) {\n    if (!window.playerStatsData)\n        return;\n    for (const mutation of mutations) {\n        if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n            for (const node of mutation.addedNodes) {\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    const element = node;\n                    if (element.querySelector(\"table[data-v-a81c915e]\")) {\n                        new StatsVisualizer(window.playerStatsData, element);\n                    }\n                }\n            }\n        }\n    }\n}\nexport function handlePlayerData(data) {\n    window.playerStatsData = new PlayerStats(data);\n    const event = new CustomEvent(\"playerDataReady\");\n    window.dispatchEvent(event);\n}\nexport function manipulatePlayerPage(table) {\n    if (window.playerStatsData) {\n        new StatsVisualizer(window.playerStatsData, table);\n    }\n    else {\n        const handler = () => {\n            new StatsVisualizer(window.playerStatsData, table);\n            window.removeEventListener(\"playerDataReady\", handler);\n        };\n        window.addEventListener(\"playerDataReady\", handler);\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { handlePlayerData } from \"./pages/player.ts\";\nimport { initNavigationHandler } from \"./navigation-handler\";\n\n(function () {\n  initNavigationHandler(); // Initialize Observer from script context\n\n  const URL_HANDLERS = {\n    player: {\n      pattern: /\\/api\\/player\\/[^\\/]+$/,\n      handler: (data) => {\n        handlePlayerData(data);\n      },\n    },\n    roster: {\n      pattern: /\\/api\\/team\\/[^\\/]+\\/roster/,\n      handler: (data) => {\n        // console.log(\"Found roster data:\", data);\n      },\n    },\n  };\n\n  function findHandler(url) {\n    for (const { pattern, handler } of Object.values(URL_HANDLERS)) {\n      if (pattern.test(url)) return handler;\n    }\n    return null;\n  }\n\n  // intercept XHR\n  const originalOpen = XMLHttpRequest.prototype.open;\n  const originalSend = XMLHttpRequest.prototype.send;\n\n  XMLHttpRequest.prototype.open = function (method, url, ...rest) {\n    this._interceptedUrl = url;\n    return originalOpen.apply(this, arguments);\n  };\n\n  XMLHttpRequest.prototype.send = function (...args) {\n    let handler;\n    if (this._interceptedUrl && (handler = findHandler(this._interceptedUrl))) {\n      const originalOnReadyState = this.onreadystatechange;\n\n      this.onreadystatechange = function () {\n        if (this.readyState === 4 && this.status === 200) {\n          try {\n            const data = JSON.parse(this.responseText);\n            handler(data);\n          } catch (e) {\n            console.error(\"Error parsing response:\", e);\n          }\n        }\n\n        if (originalOnReadyState) {\n          originalOnReadyState.apply(this, arguments);\n        }\n      };\n    }\n\n    return originalSend.apply(this, args);\n  };\n\n  // intercept fetch as well, although I don't think this is used\n  const originalFetch = window.fetch;\n  window.fetch = async function (resource, init) {\n    // handle strings & request obj\n    const url = typeof resource === \"string\" ? resource : resource.url;\n    const response = await originalFetch.apply(this, arguments);\n\n    let handler;\n    if (url && (handler = findHandler(url))) {\n      try {\n        const clonedResponse = response.clone();\n        const data = await clonedResponse.json();\n        handler(data);\n      } catch (e) {\n        console.error(\"Error processing fetch response:\", e);\n      }\n    }\n    return response;\n  };\n})();\n"],"names":[],"sourceRoot":""}